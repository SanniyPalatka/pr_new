























































































/*

Вар 1 -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
1. Парадигма ООП. Основные принципы ООП и их реализация в Java и C++.
ООП: Объе́ктно-ориенти́рованное программи́рование (ООП) — методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определенного класса,
а классы образуют иерархию наследования.
Сегодня ООП — самая распространенная методология программирования.
Помимо Java принципы ООП используются во многих популярных языках, о которых ты, возможно, слышал. Это C++
Принцип 1. Наследование
Хорошая новость: с некоторыми из принципов ООП ты уже знаком! :) Наследование нам уже пару раз встречалось в лекциях, и мы успели с ним поработать.
Наследование — механизм, который позволяет описать новый класс на основе существующего (родительского). При этом свойства и функциональность родительского класса заимствуются новым классом.
Для чего нужно наследование и какие преимущества оно дает?
Прежде всего — повторное использование кода. Поля и методы, описанные в родительских классах, можно использовать в классах-потомках.
Если у всех типов автомобилей есть 10 общих полей и 5 одинаковых методов, тебе достаточно вынести их в родительский класс Auto. Ты сможешь использовать их в классах-потомках безо всяких проблем.
Сплошные плюсы: и количественно (меньше кода), и, как следствие, качественно (классы становятся гораздо проще).
При этом механизм наследования очень гибкий, и недостающую в потомках функциональность ты можешь дописать отдельно (какие-то специфические для конкретного класса поля или поведение).

Принцип 2. Абстракция
Это очень простой принцип. Абстракция означает выделение главных, наиболее значимых характеристик предмета и наоборот — отбрасывание второстепенных, незначительных.
Не будем изобретать велосипед и вспомним пример из старой лекции про классы.
Скажем, мы создаем картотеку работников компании. Для создания объектов «работник» мы написали класс Employee. Какие характеристики важны для их описания в картотеке компании? ФИО, дата рождения, номер социального страхования, ИНН. Но вряд ли в карточке такого типа нам нужны его рост, цвет глаз и волос. Компании эта информация о сотруднике ни к чему.
Поэтому для класса Employee мы зададим переменные String name, int age, int socialInsuranceNumber и int taxNumber, а от лишней для нас информации вроде цвета глаз откажемся, абстрагируемся.
А вот если мы создаем картотеку фотомоделей для агентства, ситуация резко меняется. Для описания фотомодели нам как раз очень важны рост, цвет глаз и цвет волос, а номер ИНН не нужен.
Поэтому в классе Model мы создаем переменные String height, String hair, String eyes.

Принцип 3. Инкапсуляция
С ним мы уже сталкивались. Инкапсуляция в Java означает ограничение доступа к данным и возможностям их изменения.
Как видишь, в его основе лежит слово «капсула». В эту «капсулу» мы прячем какие-то важные для нас данные, которые не хотим, чтобы кто-то менял.
Простой пример из жизни.
У тебя есть имя и фамилия. Их знают все твои знакомые. Но у них нет доступа к изменению твоего имени и фамилии. Этот процесс, можно сказать, «инкапсулирован» в паспортном столе: поменять имя фамилию можно только там, и сделать это можешь только ты. Остальные «пользователи» имеют доступ к твоему имени и фамилии «только на чтение» :)
Еще один пример — деньги в твоей квартире. Оставлять их на виду посреди комнаты — не лучшая идея. Любой «пользователь» (человек, пришедший к тебе домой) сможет изменить число твоих денег, т.е. забрать их. Лучше инкапсулировать их в сейфе. Доступ будет только у тебя и только по специальному коду.
Очевидные примеры инкапсуляции, с которыми ты уже работал, — это модификаторы доступа (private, public и т.д.), а также геттеры-сеттеры.
Если поле age у класса Cat не инкапсулировать, кто угодно сможет написать:
Cat.age = -1000;
А механизм инкапсуляции позволяет нам защитить поле age при помощи метода-сеттера, в который мы можем поместить проверку того, что возраст не может быть отрицательным числом.

Принцип 4. Полиморфизм
Полиморфизм — это возможность работать с несколькими типами так, будто это один и тот же тип. При этом поведение объектов будет разным в зависимости от типа, к которому они принадлежат.
Звучит сложновато? Сейчас разберемся.
Возьмем самый простой пример — животных. Создадим класс Animal с единственным методом — voice(), и двух его наследников — Cat и Dog.

public class Animal {

   public void voice() {

       System.out.println("Голос!");
   }
}

public class Dog extends Animal {


   @Override
   public void voice() {
       System.out.println("Гав-гав!");
   }
}

public class Cat extends Animal {

   @Override
   public void voice() {
       System.out.println("Мяу!");
   }
}

Теперь попробуем создать ссылку Animal и присвоить ей объект Dog.

public class Main {

   public static void main(String[] args) {

       Animal dog = new Dog();
       dog.voice();
   }
}

Как ты думаешь, какой метод будет вызван? Animal.voice() или Dog.voice()?
Будет вызван метод класса Dog:
Гав-гав!
Мы создали ссылку Animal, но объект ведет себя как Dog. При необходимости он может вести себя как кошка, лошадь или другое животное. Главное — присвоить ссылке общего типа Animal объект конкретного
класса-наследника. Это логично, ведь все собаки являются животными.
Именно это мы имели в виду, когда говорили «поведение объектов будет разным, в зависимости от того, к какому типу они принадлежат».




2. Понятие структуры данных список. Линейный список. Виды списков и их реализация в Java. Доступ к элементу списка.
Использование списков. Трудоемкость операций со списками.

List в java – это интерфейс, который предоставляет возможность поддерживать упорядоченную коллекцию. Он содержит основанные на индексах методы для вставки, обновления, удаления и поиска элементов.
Он также может иметь повторяющиеся элементы.

Что такое список (list) в Java
До этого Вы, скорее всего, были знакомы только с одним способом хранения данных - массивом. Давайте рассмотрим и другие способы. Один из таких "способов" - это хранение данных в списке.
Виды списков
Списков существует несколько. List - это только название интерфейса, который объединяет несколько реализаций:
ArrayList, LinkedList, Vector, Stack
Основное преимущество списка по сравнению с массивом - его можно легко расширять.
Если у нас есть массив на 3 элемента, а нам вдруг понадобилось положить туда 10 элементов, нам просто придется создавать новый массив на 10 элементов. Только так и никак иначе! ;(
Но со списками все по-другому. Мы можем свободно добавлять элементы в начало, середину или конец списка. Все потому, что для массива нам нужен один "сплошной" участок памяти, и чтобы его расширить,
придется искать другой "целый" кусок памяти. Но с List проще - мы просто меняем ссылки:
Связным списком (linked list) называется структура данных, в которой элементы упорядочены линейным образом. Сам порядок определяется не как в массивах по номерам этих самых составляющих, а указателями.
Последние входят в состав элементов списка, применяются для указания на следующий «этап».
Корректировка связных элементов осуществляется за постоянное время (0(1)), чего нет в массивах. Может с легкостью расширяться. Для этого достаточно добавить очередной элемент.
Но перед использованием соответствующей составляющей языка важно помнить: для поиска конкретного «предмета» требуется каждый раз проходить весь список. Время доступа к искомому = O (n).
Односвязные списки – такие объекты, которые включают в себя «маркеры»-указатели на следующий узел. Из точки А можно попасть лишь в точку Б. Так пользователь будет двигаться в самый конец перечня.
То есть, пошагово, последовательно.
Вследствие происходит образование потоков, текущих в одном заданном направлении. Полем указателя последнего элемента служит нулевое значение. То есть, NULL.

Класс LinkedList — еще одна реализация интерфейса List. Представляет из себя двусвязный список, где каждый элемент структуры содержит ссылки на предыдущий и следующий элементы.
По этим ссылкам можно переходить от одного элемента к другому.


void add(int index, E obj): добавляет в список по индексу index объект obj

boolean addAll(int index, Collection<? extends E> col): добавляет в список по индексу index все элементы коллекции col. Если в результате добавления список был изменен,
то возвращается true, иначе возвращается false

E get(int index): возвращает объект из списка по индексу index

int indexOf(Object obj): возвращает индекс первого вхождения объекта obj в список. Если объект не найден, то возвращается -1

int lastIndexOf(Object obj): возвращает индекс последнего вхождения объекта obj в список. Если объект не найден, то возвращается -1

ListIterator<E> listIterator (): возвращает объект ListIterator для обхода элементов списка

static <E> List<E> of(элементы): создает из набора элементов объект List

E remove(int index): удаляет объект из списка по индексу index, возвращая при этом удаленный объект

E set(int index, E obj): присваивает значение объекта obj элементу, который находится по индексу index

void sort(Comparator<? super E> comp): сортирует список с помощью компаратора comp

List<E> subList(int start, int end): получает набор элементов, которые находятся в списке между индексами start и end

import java.util.ArrayList;

public class Program{

    public static void main(String[] args) {

        ArrayList<String> people = new ArrayList<String>();
        // добавим в список ряд элементов
        people.add("Tom");
        people.add("Alice");
        people.add("Kate");
        people.add("Sam");
        people.add(1, "Bob"); // добавляем элемент по индексу 1

        System.out.println(people.get(1));// получаем 2-й объект
        people.set(1, "Robert"); // установка нового значения для 2-го объекта

        System.out.printf("ArrayList has %d elements \n", people.size());
        for(String person : people){

            System.out.println(person);
        }
        // проверяем наличие элемента
        if(people.contains("Tom")){

            System.out.println("ArrayList contains Tom");
        }

        // удалим несколько объектов
        // удаление конкретного элемента
        people.remove("Robert");
        // удаление по индексу
        people.remove(0);

        Object[] peopleArray = people.toArray();
        for(Object person : peopleArray){

            System.out.println(person);
        }
    }
}





3

import java.util.ArrayList;
import java.util.Arrays;

public class p {
    public static void main(String[] args){
        ArrayList<Integer> list1 = new ArrayList(Arrays.asList(1,2,3,4,5));
        ArrayList<Integer> list2 = new ArrayList(Arrays.asList(9,4,2,7,1,0,2,4));
        alternate(list1, list2);
    }

    public static void alternate(ArrayList<Integer> list1, ArrayList<Integer> list2){
        int lenList1 = list1.size();
        int lenList2 = list2.size();
        int len = lenList1 + lenList2;
        ArrayList<Integer> list3 = new ArrayList<>();

        for (int i = 0; i < len; i++)
        {
            if(i < lenList1)
                list3.add(list1.get(i));

            if(i < lenList2)
                list3.add(list2.get(i));
        }

        for(Integer integ: list3)
            System.out.println(integ);
    }

}


Вар 2 -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

1. Получение информации о типе
Класс Field
Класс Field предоставляет возможность:

получить значение поля, его тип, имя а так же модификаторы поля
получить список аннотаций, класс, в котором объявлено поле и другую информацию
установить новое значение в поле, даже если оно объявлено как private
Получение значения переменной
Для того, чтобы получить значение из класса Field существуют методы getByte(), getShort(), getInt(), getLong(), getFloat(), getDouble(), getChar(), getBoolean() и get().
Как вы уже догадались, первые 8 методов существуют для получения примитивов, а последний для получения объектов.

Car car = new Car(500, "1233");
Class<? extends Car> carClass = car.getClass();
Field serialNumberField = carClass.getDeclaredField("serialNumber");

String serialNumberValue = (String) serialNumberField.get(car); //указываем из какого объекта мы хотим получить значение
System.out.println(serialNumberValue); //output: 1233
Как видите, метод get() принимает обьект car, у которого мы и хотим спросить значение поля.

При вызове метода get() у serialNumber нам необходимо использовать кастование (от англ - cast) т.к. метод get() возвращает тип Object, но если мы знаем тип,
то мы можем воспользоваться этим и преобразовать его к нужному нам.

Car car = new Car(500, "1233");
Class<? extends Car> carClass = car.getClass();
Field horsepowerField = carClass.getDeclaredField("horsepower");

String name = horsepowerField.getName();
System.out.println(name); //output: horsepower

Class<?> type = horsepowerField.getType();
System.out.println(type); //output: int

int modifiers = horsepowerField.getModifiers();
System.out.println(modifiers); //output: 2

2.Организация программы на Java. Процесс интерпритации и компиляция.

Начнем с теории. Когда мы пишем какое-либо приложение, мы создаем файл с расширением .java и помещаем в него код на языке программирования Java. Такой файл, содержащий код, понятный человеку,
называется файлом с исходным кодом. После того, как файл с исходным кодом готов, нужно его выполнить! Но на стадии в нем содержится информация, понятная только человеку.
Java — мультиплатформенный язык программирования. Это значит, что программы, написанные на языке Java, можно выполнять на любой платформе, где установлена специальная исполняющая система Java.
Такая система называется Java Virtual Machine (JVM). Для того, чтобы перевести программу из исходного кода в код, понятный JVM, нужно её скомпилировать.
Код, понятный JVM называется байт-кодом и содержит набор инструкций, которые в дальнейшем будет исполнять виртуальная машина.
Для компиляции исходного кода в байт-код существует компилятор javac, входящий в поставку JDK (Java Development Kit). На вход компилятор принимает файл с расширением .java, содежащий исходный код
программы, а на выходе выдает файл с расширением .class, содержащий байт-код, необходимый для исполнения программы виртуальной машиной.
Компиляция — трансляция программы, составленной на исходном языке высокого уровня, в эквивалентную программу на низкоуровневом языке, близком машинному коду.
Интерпретация — пооператорный (покомандный, построчный) анализ, обработка и тут же выполнение исходной программы или запроса (в отличие от компиляции, при которой программа транслируется без её
выполнения).
Язык Java обладает как компилятором (javac), так и интерпретатором, в роли которого выступает виртуальная машина, которая построчно преобразует байт-код в машинный код и тут же его исполняет.
Таким образом, когда мы запускаем скомпилированную программу, виртуальная машина начинает её интерпретацию, то есть построчное преобразование байт-кода в машинный код, а так же его исполнение.
К сожалению, чистая интерпретация байт-кода является довольно долгим процессом и делает язык java медленным в сравнении с его конкурентами.
Дабы избежать этого, был введен механизм, позволяющий ускорить интерпретацию байт-кода виртуальной машиной. Этот механизм называется Just-in-time компиляцией (JITC).

3.

import java.util.*;

public class p {
    public static void main(String[] args){
        Map<Integer, String> states = new LinkedHashMap<Integer, String>();
        states.put(1, "Germany");
        states.put(2, "Spain");
        states.put(4, "France");
        states.put(3, "Italy");

        System.out.println(states.size());
        reverse(states);
    }

    public static void reverse(Map<Integer, String> map){
        Map<String, Integer> newStates = new LinkedHashMap<String, Integer>();
        Collection<Integer> collection = map.keySet();

        for (Integer key : collection)
            newStates.put(map.get(key), key);

        Collection<String> newCollection = newStates.keySet();

        for (String key : newCollection)
            System.out.println( " " + key + " " + newStates.get(key));
    }
}


Вар 3 -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
1.
- это способ логической группировки классов.
- комплект программного обеспечения, который может распространяться независимо и применяться в сочетании с другими пакетами.
Что может входить в состав пакетов? В пакеты могут входить следующие компоненты:
- классы;
- интерфейсы;
- вложенные пакеты;
Правила именования пакета Используется принцип такой же как при создании доменных имен, но только наоборот.
Например: ru.mirea.it.ikbo0119.ivanov.laba1

Все члены класса в языке Java - поля и методы - имеют модификаторы доступа. В прошлых темах мы уже сталкивались с модификатором public.
Модификаторы доступа позволяют задать допустимую область видимости для членов класса, то есть контекст, в котором можно употреблять данную переменную или метод.
В Java используются следующие модификаторы доступа:
public: публичный, общедоступный класс или член класса. Поля и методы, объявленные с модификатором public, видны другим классам из текущего пакета и из внешних пакетов.
private: закрытый класс или член класса, противоположность модификатору public. Закрытый класс или член класса доступен только из кода в том же классе.
protected: такой класс или член класса доступен из любого места в текущем классе или пакете или в производных классах, даже если они находятся в других пакетах
Модификатор по умолчанию. Отсутствие модификатора у поля или метода класса предполагает применение к нему модификатора по умолчанию. Такие поля или методы видны всем классам в текущем пакете.

2.Сортировка пузырьком (Bubble Sort) — это один из наиболее известных алгоритмов, суть которого состоит в последовательном сравнении двух соседних элементов.
В том случае, если предыдущий элемент больше последующего, они меняются местами.
Так выглядит сортировка пузырьком на Java:
public static void bubbleSort(int[] sortArr){
    for (int i = 0; i < sortArr.length - 1; i++) {
        for(int j = 0; j < sortArr.length - i - 1; j++) {
            if(sortArr[j + 1] < sortArr[j]) {
                int swap = sortArr[j];
                sortArr[j] = sortArr[j + 1];
                sortArr[j + 1] = swap;
            }
        }
    }
}
Алгоритм сортировки вставками на Java
Это простая сортировка, при которой массив постепенно перебирается слева направо. При этом элемент сравнивается со всеми предыдущими элементами
и размещается так, чтобы оказаться в подходящем месте среди ранее упорядоченных элементов. Так происходит до тех пор, пока набор входных данных не будет исчерпан.

Так выглядит сортировка вставками на Java:

public static void insertionSort(int[] sortArr) {
    int j;
    //сортировку начинаем со второго элемента, т.к. считается, что первый элемент уже отсортирован
    for (int i = 1; i < sortArr.length; i++) {
        //сохраняем ссылку на индекс предыдущего элемента
        int swap = sortArr[i];
        for (j = i; j > 0 && swap < sortArr[j - 1]; j--) {
            //элементы отсортированного сегмента перемещаем вперёд, если они больше элемента для вставки
            sortArr[j] = sortArr[j - 1];
        }
        sortArr[j] = swap;
    }
}

public static void main(String args[]) {
    int[] sortArr = {12, 6, 4, 1, 15, 10};
    insertionSort(sortArr);
    for(int i = 0; i < sortArr.length; i++){
        System.out.print(sortArr[i] + "\n");
    }
}

Объяснение
Предполагается, что первый элемент списка отсортирован. Переходим к следующему элементу, обозначим его i. Если х больше первого, оставляем его на своём месте.
Если он меньше, копируем его на вторую позицию,
а i устанавливаем в качестве первого элемента.
Переходя к другим элементам несортированного сегмента, перемещаем более крупные элементы в отсортированном сегменте вверх по списку, пока не встретим элемент меньше
i или не дойдём до конца списка. В первом случае i помещается на правильную позицию.




Вар 7 -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

1.
Переопределение методов. Аннотация @Override
Переопределение метода (англ. Method overriding) — это возможность реализовать метод так, чтобы он имел идентичную сигнатуру с методом класса-предка,
но предоставлял иное поведение, не вызывая коллизий при его использовании. Так же это один из инструментов реализации полиморфизма.
То есть, у нас может быть во всех классах потомках метод, у которого совпадают с методом класса-предка такие параметры: имя, перечень аргументов, возвращаемый тип,
модификатор доступа. Отличия будут только в внутренней реализации этих методов. А использование таких одноименных методов не приведет к коллизии как, например, в случае с одноименными полями
в методах и классах.
Переопределяя метод — обязательно помечайте его аннотацией @Override! Это не только спасет от потенциальных ошибок, но и повысит читаемость кода. Переопределять можно только нестатические методы.

Абстрактный метод не завершён. Он состоит только из объявления и не имеет тела:
abstract void yourMethod();
По сути, мы создаём шаблон метода. Например, можно создать абстрактный метод для вычисления площади фигуры в абстрактном классе Фигура.
А все другие производные классы от главного класса могут уже реализовать свой код для готового метода. Ведь площадь у прямоугольника и треугольника вычисляется по разным алгоритмам и
универсального метода не существует.
Если вы объявляете класс, производный от абстрактного класса, но хотите иметь возможность создания объектов нового типа, вам придётся предоставить определения для всех абстрактных
методов базового класса. Если этого не сделать, производный класс тоже останется абстрактным, и компилятор заставит пометить новый класс ключевым словом abstract.
Можно создавать класс с ключевым словом abstract даже, если в нем не имеется ни одного абстрактного метода. Это бывает полезным в ситуациях, где в классе абстрактные методы просто не нужны,
но необходимо запретить создание экземпляров этого класса.
В тоже время абстрактный класс не обязательно должен иметь только абстрактные методы. Напомню ещё раз, что если класс содержит хотя бы один абстрактный метод, то он обязан быть сам абстрактным.
Создавать объект на основе абстрактного класса нельзя.
// нельзя. даже не пытайтесь
AbstractClass abstractClass = new AbstractClass();
Абстрактный класс не может содержать какие-либо объекты, а также абстрактные конструкторы и абстрактные статические методы. Любой подкласс абстрактного класса должен либо реализовать все абстрактные методы суперкласса, либо сам быть объявлен абстрактным.


2.
Отличительной чертой многих языков программирования является работа с файлами и потоками. В Java основной функционал работы с потоками сосредоточен в классах из пакета java.io.
Ключевым понятием здесь является понятие потока. Хотя понятие "поток" в программировании довольно перегружено и может обозначать множество различных концепций.
В данном случае применительно к работе с файлами и вводом-выводом мы будем говорить о потоке (stream), как об абстракции, которая используется для чтения или записи информации
(файлов, сокетов, текста консоли и т.д.).
Поток связан с реальным физическим устройством с помощью системы ввода-вывода Java. У нас может быть определен поток, который связан с файлом и через который мы можем вести чтение
или запись файла. Это также может быть поток, связанный с сетевым сокетом, с помощью которого можно получить или отправить данные в сети. Все эти задачи: чтение и запись различных
файлов, обмен информацией по сети, ввод-ввывод в консоли мы будем решать в Java с помощью потоков.
Объект, из которого можно считать данные, называется потоком ввода, а объект, в который можно записывать данные, - потоком вывода. Например, если надо считать содержание файла,
то применяется поток ввода, а если надо записать в файл - то поток вывода.
В основе всех классов, управляющих потоками байтов, находятся два абстрактных класса: InputStream (представляющий потоки ввода) и OutputStream (представляющий потоки вывода)
Но поскольку работать с байтами не очень удобно, то для работы с потоками символов были добавлены абстрактные классы Reader (для чтения потоков символов) и Writer (для записи потоков символов).
Все остальные классы, работающие с потоками, являются наследниками этих абстрактных классов. Основные классы потоков:

Запись файлов и класс FileOutputStream
Класс FileOutputStream предназначен для записи байтов в файл. Он является производным от класса OutputStream, поэтому наследует всю его функциональность.

Через конструктор класса FileOutputStream задается файл, в который производится запись. Класс поддерживает несколько конструкторов:
FileOutputStream(String filePath)
FileOutputStream(File fileObj)
FileOutputStream(String filePath, boolean append)
FileOutputStream(File fileObj, boolean append)
Файл задается либо через строковый путь, либо через объект File. Второй параметр - append задает способ записи: eсли он равен true, то данные дозаписываются в конец файла, а при false - файл полностью перезаписывается

Например, запишем в файл строку:
import java.io.*;

public class Program {

    public static void main(String[] args) {

        String text = "Hello world!"; // строка для записи
        try(FileOutputStream fos=new FileOutputStream("C://SomeDir//notes.txt"))
        {
            // перевод строки в байты
            byte[] buffer = text.getBytes();

            fos.write(buffer, 0, buffer.length);
            System.out.println("The file has been written");
        }
        catch(IOException ex){

            System.out.println(ex.getMessage());
        }
    }
}
Для создания объекта FileOutputStream используется конструктор, принимающий в качестве параметра путь к файлу для записи. Если такого файла нет, то он автоматически создается при записи.
Так как здесь записываем строку,
то ее надо сначала перевести в массив байтов. И с помощью метода write строка записывается в файл.
Для автоматического закрытия файла и освобождения ресурса объект FileOutputStream создается с помощью конструктции try...catch.
При этом необязательно записывать весь массив байтов. Используя перегрузку метода write(), можно записать и одиночный байт:
fos.write(buffer[0]); // запись первого байта
Чтение файлов и класс FileInputStream
Для считывания данных из файла предназначен класс FileInputStream, который является наследником класса InputStream и поэтому реализует все его методы.
Для создания объекта FileInputStream мы можем использовать ряд конструкторов. Наиболее используемая версия конструктора в качестве параметра принимает путь к считываемому файлу:

FileInputStream(String fileName) throws FileNotFoundException
Если файл не может быть открыт, например, по указанному пути такого файла не существует, то генерируется исключение FileNotFoundException.
Считаем данные из ранее записанного файла и выведем на консоль:
import java.io.*;

public class Program {

    public static void main(String[] args) {

        try(FileInputStream fin=new FileInputStream("C://SomeDir//notes.txt"))
        {
            System.out.printf("File size: %d bytes \n", fin.available());

            int i=-1;
            while((i=fin.read())!=-1){

                System.out.print((char)i);
            }
        }
        catch(IOException ex){

            System.out.println(ex.getMessage());
        }
    }
}
В данном случае мы считываем каждый отдельный байт в переменную i:
while((i=fin.read())!=-1){
Когда в потоке больше нет данных для чтения, метод возвращает число -1.
Затем каждый считанный байт конвертируется в объект типа char и выводится на консоль.
Подобным образом можно считать данные в массив байтов и затем производить с ним манипуляции:

byte[] buffer = new byte[fin.available()];
// считаем файл в буфер
fin.read(buffer, 0, fin.available());

System.out.println("File data:");
for(int i=0; i<buffer.length;i++){

    System.out.print((char)buffer[i]);
}
Совместим оба класса и выполним чтение из одного и запись в другой файл:

import java.io.*;

public class Program {

    public static void main(String[] args) {

        try(FileInputStream fin=new FileInputStream("C://SomeDir//notes.txt");
                FileOutputStream fos=new FileOutputStream("C://SomeDir//notes_new.txt"))
        {
            byte[] buffer = new byte[fin.available()];
            // считываем буфер
            fin.read(buffer, 0, buffer.length);
            // записываем из буфера в файл
            fos.write(buffer, 0, buffer.length);
        }
        catch(IOException ex){

            System.out.println(ex.getMessage());
        }
    }
}
Классы FileInputStream и FileOutputStream предназначены прежде всего для записи двоичных файлов, то есть для записи и чтения байтов.
И хотя они также могут использоваться для работы с текстовыми файлами, но все же для этой задачи больше подходят другие классы.
Сериализация представляет процесс записи состояния объекта в поток, соответственно процесс извлечения или восстановления состояния объекта из потока называется десериализацией. Сериализация очень удобна, когда идет работа со сложными объектами.

Интерфейс Serializable
Сразу надо сказать, что сериализовать можно только те объекты, которые реализуют интерфейс Serializable. Этот интерфейс не определяет никаких методов, просто он служит указателем системе, что объект, реализующий его, может быть сериализован.

Сериализация. Класс ObjectOutputStream
Для сериализации объектов в поток используется класс ObjectOutputStream. Он записывает данные в поток.

Для создания объекта ObjectOutputStream в конструктор передается поток, в который производится запись:

ObjectOutputStream(OutputStream out)
Для записи данных ObjectOutputStream использует ряд методов, среди которых можно выделить следующие:

void close(): закрывает поток

void flush(): очищает буфер и сбрасывает его содержимое в выходной поток

void write(byte[] buf): записывает в поток массив байтов

void write(int val): записывает в поток один младший байт из val

void writeBoolean(boolean val): записывает в поток значение boolean

void writeByte(int val): записывает в поток один младший байт из val

void writeChar(int val): записывает в поток значение типа char, представленное целочисленным значением

void writeDouble(double val): записывает в поток значение типа double

void writeFloat(float val): записывает в поток значение типа float

void writeInt(int val): записывает целочисленное значение int

void writeLong(long val): записывает значение типа long

void writeShort(int val): записывает значение типа short

void writeUTF(String str): записывает в поток строку в кодировке UTF-8

void writeObject(Object obj): записывает в поток отдельный объект

Эти методы охватывают весь спектр данных, которые можно сериализовать.
Например, сохраним в файл один объект класса Person:
import java.io.*;

public class Program {

    public static void main(String[] args) {

        try(ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("person.dat")))
        {
            Person p = new Person("Sam", 33, 178, true);
            oos.writeObject(p);
        }
        catch(Exception ex){

            System.out.println(ex.getMessage());
        }
    }
}
class Person implements Serializable{

    private String name;
    private int age;
    private double height;
    private boolean married;

    Person(String n, int a, double h, boolean m){

        name=n;
        age=a;
        height=h;
        married=m;
    }
    String getName() {return name;}
    int getAge(){ return age;}
    double getHeight(){return height;}
    boolean getMarried(){return married;}
}
Десериализация. Класс ObjectInputStream
Класс ObjectInputStream отвечает за обратный процесс - чтение ранее сериализованных данных из потока. В конструкторе он принимает ссылку на поток ввода:
ObjectInputStream(InputStream in)
Функционал ObjectInputStream сосредоточен в методах, предназначенных для чтения различных типов данных. Рассмотрим основные методы этого класса:

void close(): закрывает поток

int skipBytes(int len): пропускает при чтении несколько байт, количество которых равно len

int available(): возвращает количество байт, доступных для чтения

int read(): считывает из потока один байт и возвращает его целочисленное представление

boolean readBoolean(): считывает из потока одно значение boolean

byte readByte(): считывает из потока один байт

char readChar(): считывает из потока один символ char

double readDouble(): считывает значение типа double

float readFloat(): считывает из потока значение типа float

int readInt(): считывает целочисленное значение int

long readLong(): считывает значение типа long

short readShort(): считывает значение типа short

String readUTF(): считывает строку в кодировке UTF-8

Object readObject(): считывает из потока объект

Например, извлечем выше сохраненный объект Person из файла:
import java.io.*;

public class Program {

    public static void main(String[] args) {

        try(ObjectInputStream ois = new ObjectInputStream(new FileInputStream("person.dat")))
        {
            Person p=(Person)ois.readObject();
            System.out.printf("Name: %s \t Age: %d \n", p.getName(), p.getAge());
        }
        catch(Exception ex){

            System.out.println(ex.getMessage());
        }
    }
}
Теперь совместим сохранение и восстановление из файла на примере списка объектов:
import java.io.*;
import java.util.ArrayList;

public class Program {

    //@SuppressWarnings("unchecked")
    public static void main(String[] args) {

        String filename = "people.dat";
        // создадим список объектов, которые будем записывать
        ArrayList<Person> people = new ArrayList<Person>();
        people.add(new Person("Tom", 30, 175, false));
        people.add(new Person("Sam", 33, 178, true));

        try(ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(filename)))
        {
            oos.writeObject(people);
            System.out.println("File has been written");
        }
        catch(Exception ex){

            System.out.println(ex.getMessage());
        }

        // десериализация в новый список
        ArrayList<Person> newPeople= new ArrayList<Person>();
        try(ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename)))
        {

            newPeople=((ArrayList<Person>)ois.readObject());
        }
        catch(Exception ex){

            System.out.println(ex.getMessage());
        }

        for(Person p : newPeople)
            System.out.printf("Name: %s \t Age: %d \n", p.getName(), p.getAge());
    }
}
class Person implements Serializable{

    private String name;
    private int age;
    private double height;
    private boolean married;

    Person(String n, int a, double h, boolean m){

        name=n;
        age=a;
        height=h;
        married=m;
    }
    String getName() {return name;}
    int getAge(){ return age;}
    double getHeight(){return height;}
    boolean getMarried(){return married;}
}


3.
class ListNode {
    ListNode next;
    int data;
}

class LinkedIntList {
    public ListNode head;
    private ListNode tail;

    void addFront(int data)           //добавить спереди
    {
        ListNode a = new ListNode();  //создаём новый элемент
        a.data = data;              //инициализируем данные.
        // указатель на следующий элемент автоматически инициализируется как null
        if(head == null)            //если список пуст
        {                           //то указываем ссылки начала и конца на новый элемент
            head = a;               //т.е. список теперь состоит из одного элемента
            tail = a;
        }
        else {
            a.next = head;          //иначе новый элемент теперь ссылается на "бывший" первый
            head = a;               //а указатель на первый элемент теперь ссылается на новый элемент
        }
    }

    void addBack(int data) {          //добавление в конец списка
        ListNode a = new ListNode();  //создаём новый элемент
        a.data = data;
        if (tail == null)           //если список пуст
        {                           //то указываем ссылки начала и конца на новый элемент
            head = a;               //т.е. список теперь состоит из одного элемента
            tail = a;
        } else {
            tail.next = a;          //иначе "старый" последний элемент теперь ссылается на новый
            tail = a;               //а в указатель на последний элемент записываем адрес нового элемента
        }
    }

    void printList()                //печать списка
    {
        ListNode t = this.head;       //получаем ссылку на первый элемент
        while (t != null)           //пока элемент существуе
        {
            System.out.print(t.data + " "); //печатаем его данные
            t = t.next;                     //и переключаемся на следующий
        }
        System.out.println();
    }


    public void addAfter(int prevEl, int nextEl){//Мстод который задали вам
        ListNode t = this.head; //Получаем ссылку на первоэлемент
        while (t!=null){
            if(prevEl==t.data){
                ListNode e = new ListNode();
                e.data = nextEl;
                e.next = t.next;
                t.next = e;
                t =e;
            }
            t = t.next;
        }

    }

    void removeAll(LinkedIntList l)
    {
        ListNode t = l.head; //Получаем ссылку на первоэлемент
        while (t!=null) {
            delElement(t.data);
            t = t.next;
        }
    }

    void delElement(int data)          //удаление элемента
    {
        if(head == null)        //если список пуст -
            return;             //ничего не делаем

        if (head.data == data) {    //если первый элемент - тот, что нам нужен
            head = head.next;       //переключаем указатель начала на второй элемент
            return;                 //и выходим
        }

        ListNode t = head;       //иначе начинаем искать
        while (t.next != null) {    //пока следующий элемент существует
            if (t.next.data == data) {  //проверяем следующий элемент
                if(tail == t.next)      //если он последний
                {
                    tail = t;           //то переключаем указатель на последний элемент на текущий
                }
                t.next = t.next.next;   //найденный элемент выкидываем
                return;                 //и выходим
            }
            t = t.next;                //иначе ищем дальше
        }
    }
}

public class p {
    public static void main(String[] args) {
        LinkedIntList l1 = new LinkedIntList();
        for(int i = 0; i<=5; i++){
            l1.addBack(i);
        }
        l1.addBack(11);
        LinkedIntList l2 = new LinkedIntList();
        for(int i = 0; i<=7; i++){
            l2.addBack(i);
        }
        l1.printList();

        l2.printList();

        l2.removeAll(l1);

        l1.printList();

        l2.printList();
    }
}



Вар 9 -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



3.
class ListNode {
    ListNode next;
    int data;
}

class LinkedIntList {
    public ListNode head;
    private ListNode tail;

    void addFront(int data)           //добавить спереди
    {
        ListNode a = new ListNode();  //создаём новый элемент
        a.data = data;              //инициализируем данные.
        // указатель на следующий элемент автоматически инициализируется как null
        if(head == null)            //если список пуст
        {                           //то указываем ссылки начала и конца на новый элемент
            head = a;               //т.е. список теперь состоит из одного элемента
            tail = a;
        }
        else {
            a.next = head;          //иначе новый элемент теперь ссылается на "бывший" первый
            head = a;               //а указатель на первый элемент теперь ссылается на новый элемент
        }
    }

    void addBack(int data) {          //добавление в конец списка
        ListNode a = new ListNode();  //создаём новый элемент
        a.data = data;
        if (tail == null)           //если список пуст
        {                           //то указываем ссылки начала и конца на новый элемент
            head = a;               //т.е. список теперь состоит из одного элемента
            tail = a;
        } else {
            tail.next = a;          //иначе "старый" последний элемент теперь ссылается на новый
            tail = a;               //а в указатель на последний элемент записываем адрес нового элемента
        }
    }

    void printList()                //печать списка
    {
        ListNode t = this.head;       //получаем ссылку на первый элемент
        while (t != null)           //пока элемент существуе
        {
            System.out.print(t.data + " "); //печатаем его данные
            t = t.next;                     //и переключаемся на следующий
        }
        System.out.println();
    }


    public void addAfter(int prevEl, int nextEl){//Мстод который задали вам
        ListNode t = this.head; //Получаем ссылку на первоэлемент
        while (t!=null){
            if(prevEl==t.data){
                ListNode e = new ListNode();
                e.data = nextEl;
                e.next = t.next;
                t.next = e;
                t =e;
            }
            t = t.next;
        }

    }

    void removeDuplicates(){
        ListNode t = this.head;
        while (t!=null) {
            ListNode n = t.next;
            while (n!=null) {
                delElement(n.data, n);
                n = n.next;
            }
            t = t.next;
        }
    }

    void delElement(int data , ListNode n)          //удаление элемента
    {
        if(head == null)        //если список пуст -
            return;             //ничего не делаем

        if (head.data == data) {    //если первый элемент - тот, что нам нужен
            head = head.next;       //переключаем указатель начала на второй элемент
            return;                 //и выходим
        }

        ListNode t = n;       //иначе начинаем искать
        while (t.next != null) {    //пока следующий элемент существует
            if (t.next.data == data) {  //проверяем следующий элемент
                if(tail == t.next)      //если он последний
                {
                    tail = t;           //то переключаем указатель на последний элемент на текущий
                }
                t.next = t.next.next;   //найденный элемент выкидываем
                return;                 //и выходим
            }
            t = t.next;                //иначе ищем дальше
        }
    }
}

public class p {
    public static void main(String[] args) {
        LinkedIntList l1 = new LinkedIntList();
        for(int i = 0; i<=5; i++){
            l1.addBack(i);
        }
        l1.addBack(11);
        l1.addBack(5);
        l1.addBack(5);
        l1.addBack(5);
        l1.addBack(2);
        l1.addBack(11);
        l1.addBack(19);
        l1.printList();

        l1.removeDuplicates();
        l1.printList();

    }
}



Вар 11 -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

3.
class ListNode {
    ListNode next;
    int data;
}

class LinkedIntList {
    public ListNode head;
    private ListNode tail;

    void addFront(int data)           //добавить спереди
    {
        ListNode a = new ListNode();  //создаём новый элемент
        a.data = data;              //инициализируем данные.
        // указатель на следующий элемент автоматически инициализируется как null
        if(head == null)            //если список пуст
        {                           //то указываем ссылки начала и конца на новый элемент
            head = a;               //т.е. список теперь состоит из одного элемента
            tail = a;
        }
        else {
            a.next = head;          //иначе новый элемент теперь ссылается на "бывший" первый
            head = a;               //а указатель на первый элемент теперь ссылается на новый элемент
        }
    }

    void addBack(int data) {          //добавление в конец списка
        ListNode a = new ListNode();  //создаём новый элемент
        a.data = data;
        if (tail == null)           //если список пуст
        {                           //то указываем ссылки начала и конца на новый элемент
            head = a;               //т.е. список теперь состоит из одного элемента
            tail = a;
        } else {
            tail.next = a;          //иначе "старый" последний элемент теперь ссылается на новый
            tail = a;               //а в указатель на последний элемент записываем адрес нового элемента
        }
    }

    void printList()                //печать списка
    {
        ListNode t = this.head;       //получаем ссылку на первый элемент
        while (t != null)           //пока элемент существуе
        {
            System.out.print(t.data + " "); //печатаем его данные
            t = t.next;                     //и переключаемся на следующий
        }
        System.out.println();
    }


    public void addAfter(int prevEl, int nextEl){//Мстод который задали вам
        ListNode t = this.head; //Получаем ссылку на первоэлемент
        while (t!=null){
            if(prevEl==t.data){
                ListNode e = new ListNode();
                e.data = nextEl;
                e.next = t.next;
                t.next = e;
                t =e;
            }
            t = t.next;
        }

    }

    void removeDuplicates(){
        ListNode t = this.head;
        while (t!=null) {
            ListNode n = t.next;
            while (n!=null) {
                delElement(n.data, n);
                n = n.next;
            }
            t = t.next;
        }
    }

    void firstLast(){
        ListNode t_time = new ListNode();
        t_time = this.head;
        ListNode t = this.head;
        while (t.next!=tail) {
            t = t.next;
        }
        t.next = t_time;
        this.tail.next = t_time.next;
        this.head = this.tail;
        t_time.next = null;

    }

    void delElement(int data , ListNode n)          //удаление элемента
    {
        if(head == null)        //если список пуст -
            return;             //ничего не делаем

        if (head.data == data) {    //если первый элемент - тот, что нам нужен
            head = head.next;       //переключаем указатель начала на второй элемент
            return;                 //и выходим
        }

        ListNode t = n;       //иначе начинаем искать
        while (t.next != null) {    //пока следующий элемент существует
            if (t.next.data == data) {  //проверяем следующий элемент
                if(tail == t.next)      //если он последний
                {
                    tail = t;           //то переключаем указатель на последний элемент на текущий
                }
                t.next = t.next.next;   //найденный элемент выкидываем
                return;                 //и выходим
            }
            t = t.next;                //иначе ищем дальше
        }
    }
}

public class p {
    public static void main(String[] args) {
        LinkedIntList l1 = new LinkedIntList();
        for(int i = 0; i<=5; i++){
            l1.addBack(i);
        }
        l1.addBack(11);
        l1.addBack(5);
        l1.addBack(5);
        l1.addBack(5);
        l1.addBack(2);
        l1.addBack(11);
        l1.addBack(19);
        l1.printList();

        l1.removeDuplicates();
        l1.printList();
        l1.firstLast();
        l1.printList();

    }
}



Вар 15 -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

import java.util.LinkedList;
import java.util.Queue;
import java.util.Random;
import java.util.Stack;

public class p {

    public static void main(String[] args) {
        Stack<Integer> s = new Stack<>();
        Queue<Integer> q = new LinkedList<>();

        System.out.println("Изначальный стэк:");
        Stack<Integer> stack = get10RandomNums();

        Stack<Integer> cloned = (Stack<Integer>) stack.clone();
        while (!cloned.isEmpty()) {
            System.out.println("Элемент: " + cloned.pop());
        }

        int stackSize = 10;

        int negativeNums = 0;
        for (int i = 0; i < stackSize; i++) {
            Integer poppedElem = stack.pop();
            if (poppedElem < 0) {
                negativeNums++;
            }
            q.add(poppedElem);
        }

        while (negativeNums != 0) {
            int qHead = q.remove();
            if (qHead < 0) {
                negativeNums--;
                stack.push(qHead);
            } else {
                q.add(qHead);
            }
        }

        while (!q.isEmpty()) {
            stack.push(q.remove());
        }

        System.out.println("Обработанный стэк:");

        while (!stack.isEmpty()) {
            System.out.println("Элемент: " + stack.pop());
        }


    }
    public static Stack<Integer> get10RandomNums() {
        Stack<Integer> s = new Stack<Integer>();
        for (int i = 0; i < 10; i++) {
            Random r = new Random();
            s.push(r.nextInt() % 10);
        }
        return s;
    }
}


Вар  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
3. Напишите универсальный класс для реализации алгоритмов сортировок. В качестве параметров используйте массив
интерфейсных ссылок.
public class GenericSort<T> {
    public static void Sort(ISortable[] array){
    }
}
interface ISortable{
    void Sort;
}


Вар 23 -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
3.
abstract class GeometricFigure {
    protected double area;

    public abstract double calculateArea();

    public static GeometricFigure createFigure(String figureType, double... params) {
        if (figureType.equalsIgnoreCase("Rectangle")) {
            return new Rectangle(params[0], params[1]);
        } else if (figureType.equalsIgnoreCase("Circle")) {
            return new Circle(params[0]);
        } else {
            return null;
        }
    }
}

class Rectangle extends GeometricFigure {
    private double length;
    private double width;

    public Rectangle(double length, double width) {
        this.length = length;
        this.width = width;
    }

    @Override
    public double calculateArea() {
        area = length * width;
        return area;
    }
}

class Circle extends GeometricFigure {
    private double radius;

    public Circle(double radius) {
        this.radius = radius;
    }

    @Override
    public double calculateArea() {
        area = Math.PI * Math.pow(radius, 2);
        return area;
    }
}

GeometricFigure rectangle = GeometricFigure.createFigure("Rectangle", 5, 10);
System.out.println("Area of rectangle: " + rectangle.calculateArea());

GeometricFigure circle = GeometricFigure.createFigure("Circle", 5);
System.out.println("Area of circle: " + circle.calculateArea());


Вар 29 -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
public class Stack<T> {
    private T[] array;
    private int top;
    private int maxSize;

    public Stack(int maxSize) {
        this.maxSize = maxSize;
        array = (T[]) new Object[maxSize];
        top = -1;
    }

    public void push(T element) {
        if (isFull()) {
            throw new StackOverflowError("Stack overflow");
        }
        array[++top] = element;
    }

    public T pop() {
        if (isEmpty()) {
            throw new EmptyStackException();
        }
        return array[top--];
    }

    public T peek() {
        if (isEmpty()) {
            throw new EmptyStackException();
        }
        return array[top];
    }

    public boolean isEmpty() {
        return top == -1;
    }

    public boolean isFull() {
        return top == maxSize - 1;
    }
}

Stack<Integer> stack = new Stack<>(10);
stack.push(1);
stack.push(2);
stack.push(3);
System.out.println(stack.pop()); // Outputs 3
System.out.println(stack.peek()); // Outputs 2


Вар 25 -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

import java.util.ArrayList;
import java.util.List;

public class Stack<T> {
    private List<T> list;

    public Stack() {
        list = new ArrayList<>();
    }

    public void push(T element) {
        list.add(element);
    }

    public T pop() {
        if (isEmpty()) {
            throw new EmptyStackException();
        }
        return list.remove(list.size()-1);
    }

    public T peek() {
        if (isEmpty()) {
            throw new EmptyStackException();
        }
        return list.get(list.size()-1);
    }

    public boolean isEmpty() {
        return list.isEmpty();
    }
}

Stack<Integer> stack = new Stack<>();
stack.push(1);
stack.push(2);
stack.push(3);
System.out.println(stack.pop()); // Outputs 3
System.out.println(stack.peek()); // Outputs 2


Вар Абстрактная фабрика -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

interface GeometricFigureFactory {
    GeometricFigure create();
}

interface GeometricFigure {
    double calculateArea();
}

class RectangleFactory implements GeometricFigureFactory {
    private double length;
    private double width;

    public RectangleFactory(double length, double width) {
        this.length = length;
        this.width = width;
    }

    @Override
    public GeometricFigure create() {
        return new Rectangle(length, width);
    }
}

class CircleFactory implements GeometricFigureFactory {
    private double radius;

    public CircleFactory(double radius) {
        this.radius = radius;
    }

    @Override
    public GeometricFigure create() {
        return new Circle(radius);
    }
}

class Rectangle implements GeometricFigure {
    private double length;
    private double width;

    public Rectangle(double length, double width) {
        this.length = length;
        this.width = width;
    }

    @Override
    public double calculateArea() {
        return length * width;
    }
}

class Circle implements GeometricFigure {
    private double radius;

    public Circle(double radius) {
        this.radius = radius;
    }

    @Override
    public double calculateArea() {
        return Math.PI * Math.pow(radius, 2);
    }
}

GeometricFigureFactory rectangleFactory = new RectangleFactory(5, 10);
GeometricFigure rectangle = rectangleFactory.create();
System.out.println("Area of rectangle: " + rectangle.calculateArea());

GeometricFigureFactory circleFactory = new CircleFactory(5);
GeometricFigure circle = circleFactory.create();
System.out.println("Area of circle: " + circle.calculateArea());




public void reverseHalf(Queue<Integer> q) {

    int size = q.size();

    int mid = size / 2;

    Stack<Integer> s = new Stack<>();

    for (int i = 0; i < mid; i++) {

        s.push(q.remove());

    }

    while (!s.isEmpty()) {

        q.add(s.pop());

    }

    for (int i = 0; i < mid; i++) {

        q.add(q.remove());

    }

}






































































































 */






