public class pr {
}





































































/*
1.Java – высокоуровневый, объектно-ориентированный язык общего назначения.
Особенности языка:
1) высокоуровневый, объектно-ориентированный;
2) ему присуща строгая статическая типизация, имеет встроенную модель безопасности (можно писать многопоточные приложения);
3) архитектурно-нейтральный, портируемость приложения;
4) высокая производительность;
5) интерпретируемый и компилируемый одновременно, поддерживает многопоточность, используется динамическая загрузка классов (по необходимости).
Основное преимущество языка Java – платформонезависимость. Термин платформонезависимость означает кроссплатформенное программное обеспечение,
то есть программное обеспечение, работающее более чем на одной аппаратной платформе и/или операционной системе. Достигается посредством виртуальной
машины Java - Java Virtual Machine (сокращенно JVM).
Выделять память физически не требуется (здесь нет работы с адресной
арифметикой как в языке Си или С++), также отсутствуют такие типы данных
как указатели.
Освобождение памяти происходит автоматически с помощью встроенного
сборщика мусора.
Сборщик мусора (garbage collector) автоматически проверяет область памяти, где находятся объекты Java программы – Java Heap (куча, обсуждалось
выше) – и уничтожает их, если они стали не нужны программе.
Алгоритм работы сборщика мусора зависит от конкретной платформы, то есть от конкретной JVM

2. Пакеты. Можно ответить так:
- это способ логической группировки классов.
- комплект программного обеспечения, который может распространяться независимо и применяться в сочетании с другими пакетами.
Что может входить в состав пакетов? В пакеты могут входить следующие компоненты:
- классы;
- интерфейсы;
- вложенные пакеты;
Правила именования пакета Используется принцип такой же как при создании доменных имен, но только наоборот.
Например: ru.mirea.it.ikbo0119.ivanov.laba1

3. Ввод/вывод
Для ввода данных используется класс Scanner из пакета java.util.
В классе есть методы для чтения очередного символа заданного типа
со стандартного потока ввода, а также для проверки существования такого
символа.
Для работы с потоком ввода необходимо создать объект класса
Scanner, при создании указав, с каким потоком ввода он будет связан.
Стандартный поток ввода (клавиатура) в Джава представлен объектом
— System.in. А стандартный поток вывода (дисплей) — уже знакомым вам
объектом System.out. Есть ещё стандартный поток для вывода ошибок —
System.err
В Джава имеется также метод nextLine(), позволяющий считывать
целую последовательность символов, т.е. строку, а, значит, полученное
через этот метод значение нужно сохранять в объекте класса String.
Существует и метод hasNext(), проверяющий остались ли впотоке
ввода какие-то символы.
В классе String существует масса полезных методов, которые можно
применять к строкам (перед именем метода будем указывать тип того
значения, которое он возвращает). Некотрые из метолов:
• int length() — возвращает длину строки (количество
символов в ней);
• boolean isEmpty() — проверяет, пустая листрока;
• String replace(a, b) — возвращает строку, где символ a
(литералили переменная типа char) заменён на символ;
• String toLowerCase() — возвращает строку, где все символы
исходной строки преобразованы кстрочным;
• String toUpperCase() — возвращает строку, где все символы
исходной строки преобразованы кпрописным;
• boolean equals(s) — возвращает истинну, если строка к которой применён метод, совпадает со строкой s указанной в
аргументе метода (с помощью оператора == строки сравнивать нельзя, как и любые другие объекты);
Такие методы как nextInt и nextDouble считывают данные конкретных типов данных.
Язык Джава предоставляет возможность использовать
форматирование вывода с помощью использования
функции printf (). Для задания спецификаторов вывода
используются те же самые управляющие символы, что и в языке Си.
System.out.printf("Значение e = %.3f%n", Math.E);
В языке Джава для форматирования строкового вывода часто
используется класс Formatter. Для его использования нужно подключить
пакет java.util. Этот класс обеспечивает преобразование формата вывода
(спецификаторы формата) позволяющие выводить числа, строки, время и
даты практически в любом понравившемся вам формате. В классе Formatter
есть метод format(), который преобразует переданные в него параметры в
строку заданного формата и сохраняет в объекте типа Formatter.

4. Методы
Методы позволяют выполнять блок кода, из любого другого места,
где это доступно. Методы определяются внутри классов. Методы могут
быть статическими (можно выполнять без создания экземпляра класса), не
статическими (не могут выполняться без создания экземпляра класса).
Методы могут быть открытыми(public), закрытыми(private). Закрытые
методы могут вызываться только внутри того класса, в котором они
определены. Открытые методы можно вызывать для объекта внутри других
классов. При определении метода можно указать модификатор доступа
(public, private, protected), а также указать статический ли методключевым
словом static. Нужно обязательно указать тип возвращаемогозначения и имя
метода. В скобках можно указать аргументы, которые необходимо
передать методу для его вызова. В методе с непустым типом
возвращаемого значения нужно обязательно указать оператор return и
значение, которое он возвращает. Если метод не возвращает никакого
значения, то указывается тип void.
Модификаторы методов:
- abstract – абстрактность метода (тело при этом не описывается);
- static – статичность метода (метод принадлежит контексту класса);
- final – завершенность метода (метод не может быть переопределен при
наследовании);
- synchronized – синхронизированность метода (особенности вызова
метода в многопоточных приложениях);
- native – «нативность» метода (тело метода не описывается, при вызове
вызывается метод из native-библиотеки);
- strictfp – повышенные требования к операциям с плавающей точкой.
Особенности методов
- Для нестатических методов вызов через ссылку на объект или в контексте
объекта reference.method();methodReturningReference().method();
- Для статических методов вызов через имя типа, через ссылку на объект
или в контексте класса
ClassName.staticMethod();reference.staticMethod();staticMeth
odReturningReference().method();
- Наличие круглых скобок при вызове обязательно, т.к. они являются
оператором вызова метода
На время выполнения метода управление передается в тело метода.
Возвращается одно значение простого или объектного типа
return someValue.
Аргументы передаются по значению, т.е. значения параметров копируются в
стек. Для примитивных типов копируются сами значения, а для ссылочных типов
копируется значение ссылки. Перегруженными являются методы с одинаковыми
именами и различными сигнатурами.

5.JVM
Каждый исполняемый файл может выполняться только в «нативной» ОС, то есть той для которой он разработан.
Компилируемые для выполнения в одной ОС программы не могут выполняться в другой ОС.
Вместо этого они выполняются JVM, которая содержит отличия одной ОС от другой и представляет идентичную среду для выполнения java программ.
JVM это основная идея, которая делает Java платформонезависимым языком.
Исходный код на языке Java сначала обрабатывается компилятором, в результате получается байт код, который является универсальным и может выполнятся в любой среде, для которой есть виртуальная
машина Java (JVM). Язык Java стал чрезвычайно популярным именно благодаря
своей кроссплатформенности. Обратная сторона медали JVM это то, что Java программы работают
намного медленнее чем такие же на Си, но для большинства приложений это не существенное замедление.
В качестве основных причин медленной работы Java можно назвать:
1) динамическое связывание: в отличие от программ на языке Cи, связывание выполняется во время выполнения, каждый раз, когда программа запускается на Java.
2) работа интерпретатора времени выполнения: преобразование байткода в собственный машинный код выполняется во время выполнения программы на Java, что еще больше снижает скорость
Однако последняя версия Java в значительной степени устранила узкие места в производительности, в том числе из-за связи с аппаратурой.
Работает с аппаратно-независимым байт-кодом, полученным на этапе компиляции исходного кода в байт-код. Байт-код может быть запущен на любом
компьютере (win/mac/unix), на котором установлена JVM. Программная реализация JVM содержится в составе Java Runtime Environment (JRE). JRE можно
установить отдельно – а можно, в составе Java Development Kit (JDK).
Рассмотрим основные компоненты работы JVM:
1) ClassLoader это - загрузчик классов, фактически это подсистема, используемая для загрузки файлов классов. Он выполняет три функции: загрузка, связывание и инициализация.
2) Область метода. Область методов JVM хранит структуры классов,
такие как метаданные, постоянный пул времени выполнения и код
для методов.
3) Heap или куча. Все объекты, связанные с ними переменные экземпляра и массивы хранятся в куче. Эта память является общей и разделяется между несколькими потоками.
4) Языковые стеки JVM. Стеки языка Java хранят локальные переменные и частичные результаты. Каждый поток имеет свой собственный
стек JVM, создаваемый одновременно с созданием потока. Новый
фрейм создается при каждом вызове метода и удаляется, когда процесс вызова метода завершен.
5) Регистры ПК. В регистре ПК хранится адрес инструкции виртуальной машины Java, которая выполняется в данный момент. В Java
каждый поток имеет свой отдельный регистр ПК.
6) Собственные стеки методов. Стеки собственных методов содержат
инструкции собственного кода, зависящие от собственной библиотеки. Он написан на другом языке вместо Java

6. ООП
Напомним основные принципы ООП:
- Инкапсуляция:
объединение данных и методов их обработки в одну сущность, приводящее к
сокрытию реализации класса и отделению его внутреннего представления от
внешнего.
- Полиморфизм:
способность объекта соответствовать во время выполнения двум или более
возможным типам.
- Наследование:
отношение между классами, при котором один класс использует структуру или
поведение другого (одиночное наследование) или других (множественное
наследование) классов.
Отношения между классами.
Классы в ООП программах могут находиться между собой в различных
отношениях:
- Наследование:
Объекты дочернего класса наследуют свойства родительского класса.
- Ассоциация:
Объекты классов вступают во взаимодействие между собой.
- Агрегация:
Объекты разных классов образуют целое, оставаясь самостоятельными.
- Композиция:
Объекты одного класса входят в объекты другого, не обладая самостоятельностью.
- Класс-метакласс:
Экземплярами класса являются классы.
Достоинства ООП.
Основные достоинства, которые мы получаем6 программируя в стиле ООП:
- Упрощение разработки:
Разделение функциональности, локализация кода, инкапсуляция.
- Возможность создания расширяемых систем:
Обработка разнородных структур данных, изменение поведения на этапе
выполнения, работа с наследниками.
- Повторное использование кода.
- Легкость модернизации с сохранением совместимости.
Недостатки ООП.
Можно перечислить следующие недостатки ООП программ:
- Неэффективность на этапе выполнения.
- Неэффективность в смысле распределения памяти.
- Излишняя избыточность.
- Психологическая сложность проектирования.
- Техническая сложность проектирования и документирования и
сопровождения.
Объектная модель языка Java.
На вершине иерархии наследования лежит класс Object. Это означает, что все
остальные классы являются его потомками. Это означает, что когда вы создаете
собственные классы, то вы неявным образом наследуетесь от этого класса. У этого
класса есть методы, которые вы можете переопределять в своих классах. Есть две
разновидности классов - просто классы и интерфейсы. Вы можете создавать свои
собственные классы, используя ООП, например при помощи наследования.
Итак, объектный язык Java оперирует объектами:
- Все сущности в Java являются объектами, классами либо интерфейсами.
- Строгая реализация инкапсуляции.
- Реализовано одиночное наследование от класса и множественное от
интерфейсов.

7.Типы данных
Все типы данных в языке Джава можно разделить на две группы. Первую
группу представляют примитивные типы данных – числовые типы и логический
тип. Вторую группу данных представляют объектные типы данных.

Примитивные (простые) типы данных
К простым типам данных относятся типы для представлния числовых
знасчений и также логический тип
К целочисленным типам относятся типы:
1) char – 16-битовый символ Unicode,
2) byte – 8-битовое целое число со знаком,
3) short – 16-битовое целое число со знаком,
4) int – 32-битовое целое число со знаком,
5) long – 64-битовое целое число со знаком.
Вещественные типы данных
К вещественным типам относятся типы:
1. float – 32-битовое число с плавающей точкой (IEEE 754-1985),
2. double – 64-битовое число с плавающей точкой (IEEE 754-1985).
Логический тип
Логический тип boolean допускает хранение значений true или false.

Ссылочные типы данных
Ссылочными типы — это переменные типа класс, которые используются
для ссылок на объекты.
К объектным типам относят:
1) Классы – переменные типа класс
2) Интерфейсы – ссылки интерфейсного типа
3) Перечисления –поименованные константы
4) Типы оболочки соответствуют каждому примитивному типу
Элементы массивов в виде числовых значений это:
• float – 32-битовое число с плавающей точкой (IEEE 754-1985),
• double – 64-битовое число с плавающей точкой (IEEE 754-1985)

8.Массивы
Массив является фундаментальной структурой для хранения данных в программах.
Особенность. Вы можете в массивах Джава хранить различные типы
данных, это могут быть как базовые, например примитивные или объектные
типы данных. Также вы можете хранить в качестве элементов массивов свои
собственные типы данных. В Джава есть несколько альтернативных способ объявления и инициализации массивов.
Инициализировать массив можно точно таким же способом, как в языке
Си, с помощью прямой инициализации, не указывая размерность массива.
Например, как представлено ниже:
int[] sample = {12, 56, 7, 34, 89, 43, 23, 9};
Или другим способом, если предполагается хранить в качестве элементов
массива объекты, например, как представлено ниже:
Circle[] array = { new Circle(1, 1, “red”),
new Circle(3, 4, “green”), new Circle(1, 3, “”)};
Массив в Java это объектный тип данных, соответственно у него есть некоторые поля и методы

9.Классы
Классы — это типы данных, создаваемые программистом. На этапе проектирования программы после сбора и анализа требований определяются сущности,
которые могут служить в качестве «кандидатов» для разработки класса.
Классы проектируется на этапе проектирования программы. Проектирование
программы выполняют аналитики после сбора и анализа требований в виде UML
диаграмм. Отношения между классами также определяются на этапе проектирования программы. Это могут отношения композиции, агрегации, наследования
или ассоциации. А также использования.
Модификаторы объявления класса:
- public – признак общедоступности класса;
- abstract – признак абстрактности класса;
- final – завершенность класса (класс не допускает наследования);
- strictfp – повышенные требования к операциям с плавающей точкой.
Поля класса
Объявление поля осуществляется следующим способом:
[модификаторы] <тип> {<имя> [=
<инициализирующее выражение>]};
double sum = 2.5 + 3.7;
public double val = sum + 2 * Math.sqrt(2)
Если поле явно не инициализируются, ему присваивается значение по
умолчанию его типа (0, false или null)

10.Модификаторы
В Джава существуют различные виды модификаторов. Рассмотрим вначале модификаторы видимости. Их еще называют модификаторы доступа. Роль
модификаторов видимости в программах на Джава обеспечить область видимости для данного компонента класса, в зависимости от того с каким модификатором он объявлен.
Данные и методы класса, объявленные с public доступны в любом месте программы. Данные и методы класса, объявленные с private доступны
внутри класса. Все компоненты класса, которые объявлены без модификатора
видимости по умолчанию имеет видимость и может быть доступно из любого
класса в том же пакете.

Мы используем модификатор final, например, чтобы определить константы. Три вида применения модификатора final.
final класс
final поле
final метод

11.Геттеры и сеттеры
Поскольку поля данных экземпляра объекта типа описываются с модификатором private, то класс, как правило, класс предоставляет услуги по доступу и
изменению значений полей данных класса для своих клиентов. Для этого в класс
добавляют стандартные методы класса, так называемые геттеры и сеттенры. Методы геттеры возвращают текущее значение переменной.
Методы сеттеры позволяют получить доступ к закрытому полю класса извне и изменить его значение.
Названия методов геттеров и сеттеров(мутаторов) для нашего класса выглядят как getRadius() и setRadius, где radius это название поля данных класса.

12.Конструкторы класса
в Джава есть только конструкторы, деструкторов нет как таковых. За освобождение памяти отвечает модуль сборки мусора виртуальной машины Джава.
Конструкторы в Джава
Конструкторы в Java очень похожи на конструкторы в языке С++. Вы можете перегружать конструкторы (так же, как и другие любые методы класса).
Конструктор, который не берет параметров называется «пустым конструктором». Вы можете не иметь в классе конструктора вовсе, в этом случае используется конструктор по умолчанию, как пустой конструктор.
Конструктор может вызывать другой конструктор того же самого класса, используя служебное слово‘this’.
Вызов другого конструктора можно сделать только как первую инструкцию вызова конструктора.

13. Оператор new
Обычно мы используем new oператор, чтобы создать объект.
Оператор new возвращает ссылку на объект, размещенный памяти. Как работает new? Сначала выделяется память, а потом выполняется присваивание.
Фактически это две разных операции. Создание объектов называется инстанцированием. Любой объект - экземпляр типа класс (instance of class).

14. Ссылка this
Ссылка this ссылка позволяет объекту ссылаться на себя. В языке Джава
нет указателей, на объекты можно только ссылаться.
Так как ссылка this, используется внутри метода, относится к объекту, через который метод на стадии выполнения.
Предположим, this используется в методе, названном tryMe, который вызывается следующим образом:
obj1.tryMe();
obj2.tryMe();
В первом вызове, то эта ссылка относится к obj, а во втором она относится
к obj2.
Ссылка this может использоваться, чтобы отличить переменные экземпляра класса из соответствующих параметров метода с одинаковыми именами.

15. Класс math
Класс Java Math предоставляет ряд методов для работы выполнения
математических вычислений, например таких как как min (), max (), sqrt(),
pow(), sin(), cos(), tan(), round (), abs ( ) так далее. В классе также ест
константа число PI. Все методы класса публичные и статические, поэтому
вы можете вызывать их, обратившись напрямую через точку к классу, не
создавая объект типа класс. Если размер равен int или long и результаты
выходят за пределы диапазона значений, методы addExact (), subtractExact
(), multiplyExact () и toIntExact () вызывают исключение ArithmeticException.
Для других арифметических операций, таких как увеличение,
уменьшение, деление, абсолютное значение и отрицание, переполнение
происходит только с определенным минимальным или максимальным
значением. При необходимости его следует сравнивать с максимальным и
минимальным значением. Класс Java Math имеет множество методов,
которые позволяют решать на Джава математические задачи.

16. Random
Язык Джава предоставляет три способа генерации случайных чисел
с использованием некоторых встроенных методов и классов,
перечисленных ниже:
1. Класс Random
2. Метод random ()
3. класс ThreadLocalRandom
Класс Random находится в пакете java.util, соответственно для работы
с ним вы должны импортировать этот пакет. Метод random() это метод
класса Math, он может генерировать случайные числа типа double.
Рассмотрим первый подход, с помощью класса Random. Этот класс имеет в
своём составе различные методы для создания случайных чисел. Все они
публичные и статические. Чтобы использовать этот класс для генерации
случайных чисел, мы должны сначала создать экземпляр этого класса, а
затем уже вызвать его методы, например такие как nextInt (), nextDouble (),
nextLong () и тому подобные. С помощью этого класса мы можем
генерировать случайные числа различных типов: integer, float, double, long,
boolean. Мы можем передать аргументы методам для определения верхней
границы диапазона генерируемых чисел. Например, если вызвать метод
nextInt (6) с аргументом 6, то будет генерироваться число в диапазоне от 0
до 5 включительно.
Рассмотрим второй способ с помощью метода Math.random (). Класс
Math содержит различные методы для выполнения различных числовых
операций, таких как вычисление возведения в степень, логарифмы и т. Д.
Один из этих методов - random(), возвращает значение типа double с
положительным знаком, больше или равно 0,0 и меньше 1,0. Возвращаемые
значения выбираются псевдослучайно. Этот метод может генерировать
только случайные числа типа Double.

17. Классы оболочки
В языке Джава у каждого примитивного типа есть соответствующий
этому типу ссылочный или объектный тип класс – оболочка или обертка.
Ссылочный тип данных — это объект. В табл. 3.1 приведены
примитивные типы данных и соответствующие им классы обертки:
Таблица 3.1 Соответствие примитивных и ссылочных типов
Примитивный тип Тип оболочка
byte Byte
short Short
int Integer
long Long
float Float
double Double
boolean Boolean
char Character
Типы оболочки используются в Джава, поскольку контейнеры не
могут хранить примитивные типы данных. Поэтому необходимо выполнять
преобразование примитивного типа к ссылочному. Это называется
автоупаковка. Обратное преобразование называется автораспаковка.
Рассмотрим на примере класса Integer работу методов класса
оболочки. Класс Integer — это класс оболочка для примитивного типа int. У
класса Integer есть одно только поле типа int. Так как Integer это оболочка,
то основгная его задача предоставить различные методы для работы с int, а
также ряд методов для преобразования int в String и String в int.
У класса Integer есть метод Integer.parseInt(String s). метод
возвращает целое число, а именно возвращают примитивный тип данных
int. Также у него есть переопределений метод Integer.toString() который
возвращает строку (String) то есть символьное представление числа.

18.Перечесления enum
Перечисления это один из объектных типов в Джава. Они являются
безопасными типами, поскольку переменная тип перечисление может
принимать значение только константу из перечисления. Рассмотрим
пример объявления перечисления в языке Джва:
public enum Level {
 HIGH,
 MEDIUM,
 LOW
}
Обратите внимание на enum - ключевое слово перед именем
перечисления, которое используется вместо class или interface. Ключевое
слово enum сигнализирует компилятору Java, что это определение типа
является перечислением. Вы можете ссылаться на константы в
приведенном выше перечислении следующим образом:
Level level = Level.HIGH;
В этом случае переменная level принимает значение HIGH.
Обратите внимание, что level переменная имеет тип, Level который
является типом перечисления Java, определенным в приведенном выше
примере. Level.
Переменная может принимать одно значение из констант
перечисления Level, то есть в качестве значения может принимать значения
HIGH, MEDIUM, или LOW.
Класс перечисления автоматически получает метод toString()при
компиляции. Метод toString() возвращает строковое значение для данного
экземпляра перечисления.
Пример:
Строка levelText = Level.HIGH.toString ();
Значением переменной levelText после выполнения вышеуказанного
оператора будет текст HIGH.
Печать перечислений
Вы можете вывести на значение перечисления обычным способом, с
помощью метода println(), например таким образом:
System.out.println (Level.HIGH);
Затем будет вызван метод toString(), поэтому значение, которое будет
распечатано, будет именем экземпляра перечисления - текст. Другими
словами, в приведенном выше примере будет напечатан текст HIGH.
Вы можете добавлять поля данных в перечисление Джава, также как
в классы. Таким образом, каждое константа перечисления получает эти
поля. Значения полей должны быть переданы конструктору перечисления
при определении констант. Пример приведен на листинге 4.1.
Лстинг 4.1 – Пример перечисления Level
public enum Level {
 HIGH(3), //вызов конструктора со значением
3
 MEDIUM(2), // вызов конструктора со
значением 2
 LOW(1) // вызов конструктора со значением
1
/* нужна точка с запятой, если после констант
следуют поля и методы*.
 ;
//определение полей перечисления
 private final int levelCode;
 private Level(int levelCode) {
 this.levelCode = levelCode;
 }
}
Обратите внимание, как у перечисления в приведенном выше
примере есть конструктор, который принимает параметр типа int.
Конструктор перечисления устанавливает поле int. Когда определены
постоянные значения перечисления, int значение передается конструктору
перечисления. Конструктор для перечисления должен быть объявлен с
модификатором private. Вы не можете использовать конструкторы с
модификаторами public или protected для перечислений в Джава. Если вы
не укажете модификатор доступа в конструкторе перечисления, то он будет
объявлен неявным образом с модификатором private.

19.метод toString()
Метод toString() это метод класса Object, который лежит на вершине иерархии классов java. Создавая собственные классы, мы неявным образом наследуемся от класса Object.
Для все пользовательских классов необходимо переопределить метод toString(). Метод toString() возвращает значение символьной
строки, для того чтобы тем самым представить данный объект . Он вызывается
автоматически, когда объект конкатенируется со строкой или когда он передается внутрь метода println().

20. Наследование
Классы в программных системах и модулях, могут иметь различные типы
отношений друг с другом. Три из наиболее распространенных отношений:
• Отношение Агрегация: A has-a B
• Отношение Зависимость: A uses B
• Отношение Наследование: A is-a B

Отношение зависимости
Зависимость существует, когда один класс зависит от другого каким-то образом, как правило, путем вызова методов другого
Хороший дизайн программы лежит где-то посередине между этими утверждениями:
• многочисленные или сложные зависимости между классами
• сложные классы, которые не зависят от других классов
Некоторые зависимости происходят между объектами одного и того же
класса. Метод класса может принимать объект одного и того же класса в качестве
параметра. Например, метод concat() класса String принимает в качестве параметра другой объект
String str3 = str1.concat(str2);

Отношение Агрегация
Агрегация представляет собой сложный объект, который состоит из других объектов. Поэтому агрегация является отношением между классами has-a .
Пример агрегации: машина имеет (has a) двигатель.
В программном обеспечении, часто бывает, что совокупность объектов содержит ссылки на другие объекты, как данные экземпляра. Совокупный объект
определяется частично объектами, которые его создают. Это особый вид зависимости - агрегация, как правило, зависит от объектов, составляющих его

Наследование один из основных принципов разработки объектноориентированных программ. В терминологии Джава базовый класс, от
которого производится наследование называется суперкласс. Производные
классы, называются подклассы наследуют все компоненты родителей (поля
и методы) кроме конструкторов и статических компонентов. Обратится к
методам родительского класса можно, используя служебное слово super.
Основное преимущество наследования — это возможность повторного
использования кода. Наследование поддерживает концепцию
«возможности повторного использования», т.е. когда мы хотим создать
новый класс и уже существует класс, который включает в себя часть кода,
который нам нужен, мы можем получить наш новый класс из уже
существующего класса. Таким образом, мы повторно используем поля и
методы уже существующего класса. Для организации наследования в
Джава, используется ключевое слово – extends, что в переводе на русский
означает расширяет. Таким образом создавая производный класс с
помощью наследования, мы расширяем родительский класс как новыми
свойствами – поля данных, так добавляем к нему новое поведение – методы
класса.
Ссылка на объект может ссылаться только на объект своего же типа ( типа
класса), или на объект любого класса, связанного с ним наследованием.
Например, если класс BankAccount используется для создания класса под
названием CheckingAccount, то ссылку на объект BankAccount можно использовать, чтобы ссылаться на объект CheckingAccount
Переопределение при наследовании и использование служебного слова
super()
Служебное слово super() означает ссылку на базовый класс, которую
можно использовать в дочерних классах.
Переопределение обозначается с помощью аннотации Overriding.
Означает переписывание (переделывание, переопределение) в классе-потомке УЖЕ существующего метода класса-родителя.
Полиморфизм в Java
Определение полиморфизма: свойство системы, позволяющее использовать объекты с одинаковым интерфейсом без информации о типе и внутренней
структуре объекта.


21.Абстрактные классы
Класс, содержащий абстрактные методы, называется абстрактным
классом. Такие классы при определении помечаются ключевым словом
abstract.
Абстрактный метод внутри абстрактного класса не имеет тела, только
прототип. Он состоит только из объявления и не имеет тела:
abstract void yourMethod();
По сути, мы создаём шаблон метода. Например, можно создать
абстрактный метод для вычисления площади фигуры в абстрактном классе
Фигура. А все другие производные классы от главного класса могут уже
реализовать свой код для готового метода. Ведь площадь у прямоугольника
и треугольника вычисляется по разным алгоритмам и универсального
метода не существует.
Если вы объявляете класс, производный от абстрактного класса, но
хотитеиметь возможность создания объектов нового типа, вам придётся
предоставить определения для всех абстрактных методов базового класса.
Если этого несделать, производный класс тоже останется абстрактным, и
компилятор заставитпометить новый класс ключевым словом abstract.
Абстрактный класс не может содержать какие-либо объекты, а также
абстрактные конструкторы и абстрактные статические методы. Любой
подкласс абстрактного класса должен либо реализовать все абстрактные
методы суперкласса, либо сам быть объявлен абстрактным.

22. Класс Object
Класс Object это самый верхний класс в иерархии классов объектной модели языка Джава. Все классы в Джава и классы стандартной библиотеки Джава,
так и классы, разработанные вами, являются наследниками Object
Класс Object имеет много полезных методов.
Некотрые из методов Object:
• boolean equals(Object obj);
• String toString(); // необходимо переопределять
• int hashCode();
• Object clone();
Метод toString() мы уже неоднократно переопределяли в своих классах.
Метод equals() позволяет сравнивать объекты. Метод hashCode() возвращает
хэш-код для объекта. Метод clone() позволяет создать копию объекта.

23. Полиморфизм
Полиморфизм является одним из принципов объектно-ориентированного
программирования, и позволяет нам создавать универсальные конструкции программного обеспечения. Полиморфизм в Джава реализуется следующими способами:
• использование наследования для создания полиморфных ссылки
• использование интерфейсов для создания полиморфных ссылок
На основе использования полиморфизма мы можем реализовывать универсальные алгоритмов, например, алгоритмы сортировки и поиска
Термин полиморфный в буквальном смысле переводится как «имеющий
много форм"». Разновидности проявления полиморфизма в Джава с использованием полиморфных ссылок:
• через полиморфные ссылки, которые являются переменными, но в
разные моменты времени могут относиться к различным типам объектов;
• через методы, вызываемые через полиморфные ссылки, ведь метод
может изменяться от одного вызова к другому, в зависимости от значения котрое
принимает ссылка.

24.Стандартные интерфейсы
Библиотека стандартных классов Java содержит много полезных интерфейсов. Интерфейс Comparable одержит один абстрактный метод, называемый
compareTo, которая используется для сравнивать два объекта.
Мы обсудим метод compareTo() при обсуждении класса String. Класс String
реализует Comparable, то дает нам возможность поставить строки в лексикографическом порядке
Интерфейс Comparable
Любой класс может реализовать Comparable чтобы обеспечить механизм
для сравнения объектов этого типа.
if (obj1.compareTo(obj2) < 0)
 System.out.println ("obj1 is less than obj2");
Значение, возвращаемое функцией compareTo() должно быть отрицательным если obj1 меньше, чем obj2 (obj1<obj2), или значение равно нулю, в том случае если равны obj1 равен объекту obj2 (obj1=obj2), или положительно, если obj1
больше, чем obj2 (obj1>obj2),. Когда программист проектирует класс, который
реализует интерфейс Comparable, то он должен следовать этому правилу. Нельзя
менять семантику этого метода.
Интерфейс Iterator
Итератор создается формально, реализовав интерфейс Iterator, который содержит три метода. Метод hasNext() возвращает логический результат - истинно,
если есть элементы, которые остались для обработки. Метод next() метод возвращает следующий объект в итерации. Метод remove() удаляет объект, который
совсем недавно, возвратил next.()
Реализуя интерфейс Iterator, вaш класс формально устанавливает, что объекты этого типа являются итераторами. Программист должен решить, как
наилучшим образом реализовать функции итератора. После того, как появилась
версия for-each для цикла (начиная с Java 5) можно использовать итераторы для
обработки элементов с помощью итераторов.

Использование интерфейсных ссылок, которые являются потенциально
полиморфными дает нам большое преимущество. Использую этот механизм
языка Джава мы можем писать универсальные алгоритмы для обработки различных типов данных. Продемонстрируем всю мощь полиморфизма на примере реализации алгоритмов сортировки и поиска
Алгоритм сортировка выбором
Кратко описать суть подхода к организации алгоритма сортировки выбором можно с помощью ряда последовательных шагов:
1. выбрать значение и поместить его на его окончательное месте в
списке;
2. повторить пункт 1 для всех остальных значений элементов массива.
Если рассмотреть работу алгоритма более детально, то работу алгоритма
можно описать таким образом:
- найти наименьшее значение в списке элементов
- поменять его со значением в первого элемента
- найти следующее наименьшее значение в списке
- поменять его со значением второго элемента
- повторять, пока все значения не будут находятся на своих местах
Полиморфизм в алгоритмах сортировки
Напомним, что класс, который реализует интерфейс Comparable определяет метод compareTo(), чтобы определить относительный порядок своих объектов. Мы можем использовать полиморфизм, чтобы разработать обобщенную
сортировку для любого набора Comparable объектов. Метод сортировки принимает в качестве параметра массив Comparable объектов. Таким образом, один метод, может быть, использован для сортировки любых объектов, например: People
(людей), Books (книг), или любой каких-либо других объектов.
Реализация алгоритма сортировка выбором на языке Джава
Методу сортировки все-равно, что именно он будет сортировать, ему
только необходимо иметь возможность вызвать метод compareTo(). Это обеспечивается использованием интерфейса Comparable как типа параметра. Кроме
того, таким образом каждый класс “для себя” решает, что означает для одного
объекта, быть меньше, чем другой. На листинге 4.1 представлен класс, которой
представляет описание сущности предметной области – контакт, соответствующий записи абонента в телефонной книжке.

public class Contact implements Comparable{
private String firstName;// имя абонента
private String lastName; //фамилия абонента
private String phone; // телефон абонента
//конструктор класса Contact
public Contact (String first, String last, String
telephone) {
this.firstName = first;
this.lastName = last;
this.phone = telephone;
}
//переопределённый в классе toString ()
public String toString () { return lastName + ", " +
firstName + "\t" + phone;}
// переопределённый в классе equals (Object other)
public boolean equals (Object other) {
return (lastName.equals(((Contact)other).getLastName()) && firstName.equals(((Contact)other).getFirstName()));
}
//геттеры для полей firstName и lastName
public String getFirstName () {return firstName; }
public String getLastName () {return lastName;}
// реализация метода интерфейса Comparable
public int compareTo (Object other){
int result;
String otherFirst =((Contact)other).getFirstName();
String otherLast = ((Contact)other).getLastName();
if (lastName.equals(otherLast))
 result = firstName.compareTo(otherFirst);
else
 result = lastName.compareTo(otherLast);
return result;
}}
Обратите внимание, что класс Contact реализует интерфейс Comparable, в нем есть реализация метода compareTo(), для этого пришлость переопределить метод equals() родительского класса Object.

Алгоритм сортировка вставками
Рассмотрим еще один популярный алгоритм сортировки – алгоритм вставками.
Работа метода сортировки — это последовательное выполнение шагов:
1. выбрать любой элемент и вставить его в надлежащее место в отсортированный подсписок
2. повторять пункт 1, до тех пор, пока все элементы не будут вставлены
Более детально работу алгоритма можно описать так:
• рассматриваем первый элемент списка как отсортированный подсписок (то есть первый элемент списка)
• вставим второй элемент в отсортированный подсписок, сдвигая первый элемент по мере необходимости, чтобы освободить место для
вставки нового элемента
• вставим третий элемент в отсортированный подсписок (из двух элементов), сдвигая элементы по мере необходимости
• повторяем до тех пор, пока все значения не будут вставлены на свои
соответствующие позиции
На рисунке 4.2 показан пошагово результат выполнения сортировки исходного массива с помощью алгоритма сортировки вставками.

public class Sorting {
//метод сортировки выбором
public static void selectionSort (Comparable[] list){
int min;
Comparable temp; //интерфейсная ссылка
for (int index = 0; index < list.length-1; index++){
min = index;
for (int scan = index+1; scan < list.length;
scan++)
if (list[scan].compareTo(list[min]) < 0)
 min = scan;
 temp = list[min];
 list[min] = list[index];
 list[index] = temp;
 } // end if
} // end for
}}
//алгоритм сортировки вставками
public static void insertionSort (Comparable[] list){
for (int index = 1; index < list.length; index++) {
Comparable key = list[index];
int position = index;
// Сдвигаем большие значения вправо
while (position > 0 && key.compareTo(list[position-1]) < 0) {
list[position] = list[position-1];
position--;
 }//end while
 list[position] = key;
 }//end for
}// end method
класс тестер или у вас может называться Main, здесь
называется DemoPhoneList, демонстрируем работу работу
обоих методов сортировки
public class DemoPhoneList{
    public static void main (String[] args) {
        Contact[] friends = new Contact[8];//массив абонентов
//создаем записи с помощью конструктора
        friends[0] = new Contact ("John", "Smith", "610-555-
                7384");
                friends[1] = new Contact ("Sarah", "Barnes", "215-
                        555-3827");
                        friends[2] = new Contact ("Mark", "Riley", "733-555-
                                2969");
friends[3] = new Contact ("Laura", "Getz", "663-555-
3984");
friends[4] = new Contact ("Larry", "Smith", "464-555-
3489");
friends[5] = new Contact ("Frank", "Phelps", "322-
555-2284");
friends[6] = new Contact ("Mario", "Guzman", "804-
555-9066");
friends[7] = new Contact ("Marsha", "Grant", "243-
555-2837");
Sorting.selectionSort(friends);
//печатаем массив после сортировки с помощью for:each
 for (Contact friend : friends) System.out.println
(friend);
}
}

Два метода поиска в одном классе
Рассмотрим еще один пример, демонстрирующий преимущества полиморфизма, напишем класс Searching и добавим туда два метода реализации поиска.
Наш класс будет содержать метод линейного поиска и бинарного поиска.
В нашем примере оба метода поиска будут возвращать интерфейсную ссылку, то
есть сам искомый элемент в массиве, но это не обязательно вы при реализации
можете возвращать любой тип, например логический тип

public class Searching{
// метод для линейного поиска
public static Comparable linearSearch (Comparable[]
list,Comparable target) {
int index = 0;
boolean found = false;
while (!found && index < list.length) {
 if (list[index].compareTo(target)==0)
 found = true;
 else
 index++;
} //end while
if (found) //если элемент найден
 return list[index]; //да
else
 return null;//не нашли
}//конец метода
//Бинарный поиск
public static Comparable binarySearch (Comparable[]
list,Comparable target) {
int min=0, max=list.length-1, mid=0;
boolean found = false;
while (!found && min <= max) {
 mid = (min+max) / 2;
 if (list[mid].compareTo(target)==0)
 found = true; //нашли
 else
 if (target.compareTo(list[mid]) < 0)
 max = mid-1;
 else
 min = mid+1; }
if (found) return list[mid];
else return null;}}
//класс тестер, будем вызывать методы поиска
public class PhoneList2 {
public static void main (String[] args) {
Contact test, found;
Contact[] friends = new Contact[8];//массив записей
friends[0] = new Contact ("John", "Smith", "610-555-
7384");
friends[1] = new Contact ("Sarah", "Barnes", "215-
555-3827");
friends[2] = new Contact ("Mark", "Riley", "733-555-
2969");
friends[3] = new Contact ("Laura", "Getz", "663-555-
3984");
friends[4] = new Contact ("Larry", "Smith", "464-555-
3489");
friends[5] = new Contact ("Frank", "Phelps", "322-
555-2284");
friends[6] = new Contact ("Mario", "Guzman", "804-
555-9066");
friends[7] = new Contact ("Marsha", "Grant", "243-
555-2837");
//будем искать Frank Phelps
test = new Contact ("Frank", "Phelps", "");
//сначала ищем с пом. Линейного поиска
found = (Contact) Searching.linearSearch(friends,
test);
if (found != null)// проверяем нашли или нет
System.out.println ("Found: " + found);//нашли
else
System.out.println ("The contact was not
found."); //не нашли
System.out.println ();// пустая строка
Sorting.selectionSort(friends);// сортируем записи
// теперь ищем Mario Guzman
test = new Contact ("Mario", "Guzman", "");
found = (Contact) Searching.binarySearch(friends,
test); // записываем найденный результат в test
if (found != null)
System.out.println ("Found: " + found);//нашли
else
System.out.println ("The contact was not
found.");// не нашли
}}


Comparator и Comparable в Java
Интерфейс Comparable содержит один единственный метод int
compareTo(E item), который сравнивает текущий объект с объектом,
переданным в качестве параметра. Если этот метод возвращает
отрицательное число, то текущий объект будет располагаться перед тем,
который передается через параметр. Если метод вернет положительное
число, то, наоборот, после второго объекта. Если метод возвратит ноль,
значит, оба объекта равны.
Интерфейс Comparator
Однако перед нами может возникнуть проблема, что, если
разработчик не реализовал в своем классе, который мы хотим использовать,
интерфейс Comparable, либо реализовал, но нас не устраивает его
функциональность, и мы хотим ее переопределить? На этот случай есть еще
более гибкий способ, предполагающий применение интерфейса
Comparator<E>.
Интерфейс Comparator содержит ряд методов, ключевым из которых
является метод compare():
Листинг 10.1 – Пример интерфейса Коимпаратор
public interface Comparator<E> {
 int compare(T a, T b);
 // остальные методы
}
Метод compare также возвращает числовое значение - если оно
отрицательное, то объект a предшествует объекту b, иначе - наоборот. А
если метод возвращает ноль, то объекты равны. Для применения
интерфейса нам вначале надо создать класс компаратора, который
реализует этот интерфейс:
class PersonComparator implements
Comparator<Person>{
 public int compare(Person a, Person b){

 return
a.getName().compareTo(b.getName());
 }
}
Замечание. Предполагаем, что тип Person у нас описан был ранее как
класс
Листинг 10.3 – Пример класса Person
class Person{
 private String name;
 Person(String name){
 this.name=name;
 }
 String getName(){return name;}
}
Сортировка по нескольким критериям
Начиная с JDK 8 в механизм работы компараторов были внесены
некоторые дополнения. В частности, теперь мы можем применять сразу
несколько компараторов по принципу приоритета. Например, изменим
класс Person следующим образом:
Листинг 10.4 – Пример класс Student
class Person{
private String name;
private int age;
public Person(String name, int age){
 this.name=name;
 this.age=age;
 }
String getName(){return name;}
int getAge(){return age;}
}
Здесь добавлено поле для хранения возраста пользователя. И,
допустим, нам надо отсортировать пользователей по имени и по возрасту.
Для этого определим два компаратора:
Листинг 10.5 – Пример реализующего компаратор
class PersonNameComparator implements
Comparator<Person>{
 public int compare(Person a, Person b){
 return
a.getName().compareTo(b.getName());
 }
}
Листинг 10.6 – Пример реализующего компаратор
class PersonAgeComparator implements
Comparator<Person>{
 public int compare(Person a, Person b){

 if(a.getAge()> b.getAge())
 return 1;
 else if(a.getAge()< b.getAge())
 return -1;
 else
 return 0;
 }
}
Интерфейс компаратора определяет специальный метод по
умолчанию thenComparing, который позволяет использовать цепочки
компараторов для сортировки набора:
Листинг 10.7 – Пример реализующего компаратор
Comparator<Person> pcomp = new
PersonNameComparator().thenComparing(new
PersonAgeComparator());
TreeSet<Person> people = new TreeSet(pcomp);
people.add(new Person("Tom", 23));
people.add(new Person("Nick",34));
people.add(new Person("Tom",10));
people.add(new Person("Bill",14));
for(Person p : people){
 System.out.println(p.getName() + " " +
p.getAge());
}

25. Пользовательские интерфейсы
Интерфейс в Java это разновидность класса. В качестве компонентов
интерфейс имеет поля данных только статические константы и в качестве
методов только абстрактные методы.
Интерфейс в Java — это механизм для достижения определенного
рода абстракции. Интерфейсе Java не может включать никаких других
методов кроме абстрактных. В составе интерфейса методы только
объявлены, у них нет реализации или тела метода. Это похоже на механизм
виртуальных функций в языке С++. Интерфейс содержит только
объявления методов, то есть тело метода отсутствует. В Джава может быть
объявлен пустой интерфейс, котрый не содержит ни одного объявления
метода. Такие интерфейсы называются этикетками. Все методы входящие
в интерфейс объявляются как abstract public, но вы можете не писать это
перед самим методом, так как все методы, входящие в интерфейс и так по
умолчанию абстрактные и с открытым - public доступом (начиная с версии
Java 8). В Java 9 методы могут быть объявлены с модификатором private.
Интерфейсы используются для достижения абстракции и множественного
наследования в языке Джава. Потому что один и тот же интерфейс может
использоваться для реализации разными классами.
Интерфейс Java также представляет отношение классами “IS- a”.

Преимущества интерфейсов
Существуют по крайней мере три веские причины использовать
интерфейсы:
• они используется для достижения абстракции.
• Благодаря интерфейсам мы можем поддерживать механизм
множественного наследования.
• они использовать для достижения слабой связанности кода (low
coupling code)
Объявление интерфейсов
Интерфейс объявляется с помощью ключевого слова interface. Он
обеспечивает полную абстракцию; это означает, что все методы в
интерфейсе объявлены с пустым телом, а все поля по умолчанию являются
общедоступными, статическими и окончательными (объявлены с
модификатором final). Класс, реализующий интерфейс, должен
реализовывать все методы, объявленные в интерфейсе.
Внимание! Если вы забудете реализовать какой-нибудь из методов,
то вы получите абстрактный класс.
Синтаксис объявления интерфейса:
interface <interface_name> {

 // объявляем поля константы
 // объявляем абстрактные методы
 // (они по умолчанию абстрактные)
}
Замечание: Компилятор Java добавляет ключевые слова public и abstract
перед методом интерфейса. Более того, он добавляет ключевые слова public,
static и final перед полями данных класса.

Все методы интерфейса не имеют модификаторов доступа, но
фактически по умолчанию доступ public, так как цель интерфейса -
определение функционала для реализации его классом. Поэтому весь
функционал должен быть открыт для реализации.
И также при объявлении интерфейса надо учитывать, что только один
интерфейс в файле может иметь тип доступа public. А его название должно
совпадать с именем файла. Остальные интерфейсы (если такие имеются в
файле java) не должны иметь модификаторов доступа.
Интерфейс может определять различные методы, которые, так же как
и абстрактные методы абстрактных классов не имеют реализации. Вданном
случае объявлен только один метод.
Все методы интерфейса не имеют модификаторов доступа, но
фактически по умолчанию доступ public, так как цель интерфейса -
определение функционала для реализации его классом. Поэтому весь
функционал должен быть открыт для реализации.

Чтобы класс применил интерфейс, надо использовать ключевое слово
implements:
Листинг 7.1 – Пример 1 реализации интерфейса
class Book implements Printable{
String name;
String author;
int year;
Book(String name, String author, int year){
this.name = name;
this.author = author; this.year = year;
}
public void print() {
System.out.printf("Книга '%s' (автор %s) была
издана в %d году \n", name, author, year);}}
При этом надо учитывать, что если класс применяет интерфейс, то
он должен реализовать все методы интерфейса, как в случае выше
реализован метод print.
Потом в главном классе мы можем использовать данный класс иего
метод print:
Book b1 = new Book("Война и мир", "Л. Н. Толстой",
1863); b1.print();
В тоже время мы не можем напрямую создавать объектыинтерфейсов,
поэтому следующий код не будет работать:
Printable pr = new Printable(); pr.print();
Одним из преимуществ использования интерфейсов является то, что
они позволяют добавить в приложение гибкости. Например, в дополнение
к классу Book определим еще один класс, который будет реализовывать
интерфейс Printable:
Листинг 7.2 – Пример 2 реализации интерфейса
public class Journal implements Printable {
private String name;
String getName(){ return name;}
Journal(String name){ this.name = name;}
public void print() {
System.out.printf("Журнал '%s'\n", name);
}}
Класс Book и класс Journal связаны тем, что они реализуют
интерфейс Printable. Поэтому мы динамически в программе можем
создавать объекты Printable как экземпляры обоих классов:
Printable printable = new Book("Война и мир", "Л.
Н. Толстой", 1863);
printable.print();//для одного объекта
printable = new Journal("Хакер");
printable.print();//для другого объекта
И также, как и в случае с классами, интерфейсы могут использоваться
в качестве типа параметров метода или в качестве возвращаемого типа:
Листинг 7.3 – Пример 3 реализации интерфейса
public static void main(String[] args) {
Printable printable =
createPrintable("Компьютерра",false);
printable.print();
read(new Book("Отцы и дети", "И. Тургенев",
1862));
read(new Journal("Хакер"));
}
//статический метод класса
static void read(Printable p){
p.print();
}
//статический метод
static Printable createPrintable(String name,
boolean option){
if(option)
 return new Book(name, "неизвестен", 2015);
else
 return new Journal(name);
}
Метод read() в качестве параметра принимает объект интерфейса
Printable, поэтому в этот метод мы можем передать как объект Book,
так и объект Journal.
Метод createPrintable() возвращает объект Printable, поэтому такжемы
можем возвратить как объект Book, так и Journal.
Интерфейс Java может иметь статические методы. Статические
методы в интерфейсе Java должны иметь реализацию, в отличие от
обычных методов. Вот пример статического метода в интерфейсе Java:
Листинг 7.4 – Пример интерфейса со статическим методом
public interface MyInterface {
 public static void print (String text) {
 System.out.print (текст);
 }
}
Вызов статического метода в интерфейсе выглядит и работает так же,
как вызов статического метода в классе. Вот пример вызова статического
print() метода из MyInterface интерфейса выше :
MyInterface.print ("Привет, статический метод!");
Статические методы в интерфейсах могут быть полезны, когда у вас
есть некоторые служебные методы, которые вы хотели бы сделать
доступными, которые естественным образом вписываются в интерфейс,
связанный с той же ответственностью.
Например, Vehicle интерфейс может иметь статический метод
printVehicle(Vehicle v).

26. Рекурсия

В контексте языка программирования рекурсия — это некий
активный метод (или подпрограмма) вызываемый сам по себе
непосредственно, или вызываемой другим методом (или подпрограммой)
косвенно. Впервую очередьнадо понимать, что рекурсия — это своего рода
перебор. Вообще говоря, всё то,что решается итеративно можно решить
рекурсивно, то есть с использованием рекурсивной функции.
Так же, как и у перебора (цикла) у рекурсии должно быть условие
остановки — базовый случай (иначе также, как и цикл, рекурсия будет
работатьвечно — infinite). Это условие и является тем случаем, к которому
рекурсия идет(шаг рекурсии). При каждом шаге вызывается рекурсивная
функция до тех пор, пока при следующем вызове не сработает базовое
условие и не произойдет остановка рекурсии (а точнее возврат к
последнему вызову функции). Всё решение сводится к поиску решения для
базового случая. В случае, когда рекурсивная функция вызывается для
решения сложной задачи (не базового случая) выполняется некоторое
количество рекурсивных вызовов или шагов, с целью сведения задачи к
более простой. И так до тех пор, пока не получим базовое решение.
Итак, рекурсивная функция состоит из:
• условие остановки или же базового случая или условия;
• условие продолжения или шага рекурсии — способ сведения
сложной задачи к более простым подзадачам.
Рассмотрим это на примере нахождения факториала:
Листинг 8.1 – Пример вычисления факториала
public class Solution {
public static int recursion(int n) {
// условие выхода
// Базовый случай
// когда остановиться повторять рекурсию ? if (n ==
1) {
return 1;
}
// Шаг рекурсии / рекурсивное условие
return recursion(n - 1) * n;
}
public static void main(String[] args) {
System.out.println(recursion(5)); // вызов рекурсивной
функции
}}
Тут базовым условием является условие, когда n=1. Так как мы
знаем, что
1!=1 и для вычисления 1! нам ни чего не нужно. Чтобы вычислить 2!
мы можем использовать 1!, т.е. 2!=1!*2. Чтобы вычислить 3! нам нужно
2!*3… Чтобывычислить n! нам нужно (n-1)!*n. Это и является шагом
рекурсии.
Иными словами, чтобы получить значение факториала от числа n,
достаточно умножить на n значение факториала от предыдущего числа.

27. Работа с Датой и временем

Класс Date
Класс Date изначально предоставлял набор функций для работы с
датой - для получения текущего года, месяца и т.д. однако сейчас все эти
методы не рекомендованы к использованию и практически всю
функциональность для этого предоставляет класс Calendar. Класс Date так
же определен в пакете java.sql поэтому желательно указывать полностью
квалифицированное имя класса Date.
Существует несколько конструкторов класса Date однако
рекомендовано к использованию два
Date() и Date(long date) второй конструктор использует в качестве
параметра значение типа long который указывает на количество
миллисекунд прошедшее с 1 Января 1970, 00:00:00 по Гринвичу. Первый
конструктор создает дату использует текущее время и дату (т.е. время
выполнения конструктора). Фактически это эквивалентно второму
варианту new Date(System.currentTimeMillis); Можно уже после создания
экземпляра класса Date использовать метод setTime(long time), для того, что
бы задать текущее время.
Для сравнения дат служат методы after(Date date), before(Date date)
которые возвращают булевское значение в зависимости от того выполнено
условие или нет. Метод compareTo(Date anotherDate) возвращает значение
типа int которое равно -1 если дата меньше сравниваемой, 1 если больше и
0 если даты равны. Метод toString() представляет строковое представление
даты, однако для форматирования даты в виде строк рекомендуется
пользоваться классом SimpleDateFormat определенном в пакте java.text

Классы Calendar и GregorianCalendar
Более развитые средства для работы с датами представляет класс
Calendar. Calendar является абстрактным классом. Для различных платформ
реализуются конкретные подклассы календаря. На данный момент
существует реализация Грегорианского календаря - GregorianCalendar.
Экземпляр этого класса получается вызовом статического метода
getInstance(), который возвращает экземпляр класса Gregorian. Подклассы
класса Calendar должны интерпретировать объект Date по-разному. В
будущем предполагается реализовать так же лунный календарь,
используемый в некоторых странах. Calendar обеспечивает набор методов
позволяющих манипулировать различными "частями" даты, т.е. получать и
устанавливать дни, месяцы, недели и т.д. Если при задании параметров
календаря упущены некоторые параметры, то для них будут использованы
значения по умолчанию для начала отсчета. т.е.YEAR = 1970, MONTH =
JANUARY, DATE = 1 и т.д.
Для считывания, установки манипуляции различных "частей" даты
используются методы get(int filed), set(int filed, int value), add(int field, int
amount), roll(int field, inr amount), переменная типа int с именем filed
указывает на номер поля с которым нужно произвести операцию. Для
удобства все эти поля определены в Calendar, как статические константы
типа int. Рассмотрим подробнее порядок выполнения перечисленных
методов.
Метод set(int field,int value)
Как уже отмечалось ранее данный метод производит установку
какого - либо поля даты. На самом деле после вызова этого метода,
немедленного пересчета даты не производится. Пересчет даты будет
осуществлен только после вызова методов get(), getTime() или
TimeInMillis(). Т.о. последовательная установка нескольких полей, не
вызовет не нужных вычислений. Помимо этого, появляется еще один
интересный эффект. Рассмотрим следующий пример. Предположим, что
дата установлена на последний день августа. Необходимо перевести ее на
последний день сентября. Если внутреннее представление даты изменялось
бы после вызова метода set, то при последовательной установке полей мы
получили бы вот такой эффект.
Пример работы с датой и временем
public class Test {
public Test() {
}
public static void main(String[] args) {
SimpleDateFormat sdf = new SimpleDateFormat("yyyy
MMMM dd HH:mm:ss");
Calendar cal = Calendar.getInstance();
cal.set(Calendar.YEAR,2002);
cal.set(Calendar.MONTH,Calendar.AUGUST);
cal.set(Calendar.DAY_OF_MONTH,31);
System.out.println(" Initialy set date:”+
sdf.format(cal.getTime()));
cal.set(Calendar.MONTH,Calendar.SEPTEMBER);
System.out.println(" Date with month changed :"+
sdf.format(cal.getTime()));
cal.set(Calendar.DAY_OF_MONTH,30);
System.out.println(" Date with day changed:”+
sdf.format(cal.getTime()));
}}

Рассмотрим еще пример.
Листинг 11.2 – Пример работы с датой и временем
import java.text.SimpleDateFormat;
import java.util.Date;
public class DateTest {
public static void main(String[] args) {
Date now = new Date();
System.out.println("toString(): " + now);
// dow mon dd hh:mm:ss zzz yyyy
// h (часы): h, hh (with leading zero)
// m (минуты)
// s (секунды)
// a (AM/PM)
// H (часы 0 до 23)
// z (временная зона)
SimpleDateFormat dateFormatter = new
SimpleDateFormat("E, y-M-d 'at' h:m:s a z");
 System.out.println("Format 1: " +
dateFormatter.format(now));
 dateFormatter = new SimpleDateFormat("E
yyyy.MM.dd 'at' hh:mm:ss a zzz");
 System.out.println("Format 2: " +
dateFormatter.format(now));
dateFormatter = new SimpleDateFormat("EEEE, MMMM
d, yyyy");
 System.out.println("Format 3: " +
dateFormatter.format(now));
Вывод программы листинга 12.2
toString(): Sat Sep 25 21:27:01 SGT 2010
Format 1: Sat, 10-9-25 at 9:27:1 PM SGT
Format 2: Sat 2010.09.25 at 09:27:01 PM SGT
Format 3: Saturday, September 25, 2010

Класса Date будет достаточно, если вам просто нужна простая
отметка времени. Вы можете использовать SimpleDateFormat для
управления форматом отображения даты /времени. Используйте класс
java.util.Calendar, если вам нужно извлечь год, месяц, день, час, минуту и
секунду или манипулировать этими полями (например, 7 дней спустя, 3
недели назад)
Используйте java.text.DateFormat для форматирования даты (от даты
до текста) и разбора строки даты (от текста к дате). SimpleDateForamt
является подклассом DateFormat.
Date является устаревшим классом, который не поддерживает
интернационализацию. Calendar и DateFormat поддерживают локалзацию
(вам нужно учитывать локализацию только в том случае, если ваша
программа будет работать во нескольких странах одновременно).

Измерение времени
Любые приложения (такие как игры и анимация) требуют хорошего
контроля времени. Java предоставляет эти статические методы в классе
System. Метод System.currentTimeMillis() возвращает текущее время в
миллисекундах с 1 января 1970 г. 00:00:00 по Гринвичу (известное как
«эпоха») в длинном формате.
Измерение прошедшего времени производится как в примере ниже:
long startTime = System.currentTimeMillis();
// измерение выполнения кода
 .......
long estimatedTime = System.currentTimeMillis() -
startTime;
Метод System.nanoTime (): возвращает текущее значение наиболее
точного доступного системного таймера, в наносекундах, в течение
длительного времени. Введенный с JDK 1.5. метод nanoTime ()
предназначен для измерения относительного временного интервала вместо
предоставления абсолютного времени.

28. GUI

Теоретические сведения
Для создания графического интерфейса пользователя можно
использовать стандартную Джава библиотеку Swing или AWT. В этих
библиотеках имеются различные классы, позволяющие создавать окна,
кнопки, текстовые поля, меню и другие объекты.
КомпонентTextField
Компонент Text Fields - текстовое поле или поля для ввода текста
(можно ввести только одну строку). Примерами текстовых полей являются
поля для ввода логина и пароля, например, используемые, при входе в
электронную почту.
Пример создания объекта класса JTextField:
JTextField jta = new JTextField (10);
В параметре конструктора задано число 10, это количество символов,
которые могут быть видны в текстовом поле. Текст веденный в поле JText
может быть возвращен с помощью методаgetText(). Также в поле можно
записать новое значение с помощью метода setText(String s).
Как и у других компонентов, мы можем изменять цвет и шрифт текста
в текстовом поле.
Листинг 11.1 – Пример пользовательского класса окна, наследуемся
от JFrame
class LabExample extends JFrame{
JTextField jta = new JTextField(10);.
//можно задать свойства шрифта
Font fnt = new Font("Times new
roman",Font.BOLD,20); LabExample(){
// вызываем конструктор родителя JFrame
super("Example");
//устанавливаем менеджер компоновки FlowLayout
setLayout(new FlowLayout());
//устанавливаем размеры окна
setSize(250,100);
//добавляем текстовое поле к окну
add(jta);
//задаем цвет фона
jta.setForeground(Color.PINK);
//задаем цвет шрифта
jta.setFont(fnt);
setVisible(true);
}
public static void main(String[]args){
//вызываем конструктор класса LabExample
new LabExample();
}
}
Важное замечание.
Ответственность за выполнение проверки на наличие ошибок в коде
лежит полностью на программисте, например, чтобы проверить произойдет
ли ошибка, когда в качестве входных данных в JTextField ожидается ввод
числа. Компилятор не будет ловить такого рода ошибку, поэтому ее
необходимо обрабатывать пользовательским кодом.

Менеджер Layout по умолчанию
Иногда бывает нужно изменить размер и расположение компонента в
контейнере. Таким образом, мы должны указать программе не использовать
никакой менеджер компоновки, то есть использовать setLayout (null). Так
что мы получим что-то вроде этого:
Листинг 11.5 – Пример программы
import javax.swing.*;
import java.awt.*;
importjava.awt.event.*;
class NullLayout extends JFrame{
JButton but1 = new JButton("One");
JButton but2 =new JButton("two");
JButton but3 = new JButton("three");
public NullLayout(){
setLayout(null);
but1.setBounds(150,300,100,20);
// добаволяем 150,300 ширина = 100, высота =20
but2.setSize(80,400);
// добавляем к 0,0 ширина = 80, высота =400
but3.setLocation(300,1 00);
but3.setSize(200,75);
// those two steps can be combined in onesetBounds
method call
add(but1);
add(but2);
add(but3);
setSize(500,500);
}
public static void main(String[]args){
new NullLayout().setVisible(true);
}
}

29.Работа со строками
Для работы со строками в Джава используются несколько классов? Например такие:
• Класс String
• StringBuffer
• StringBuilder

Особенности использования строк в Java
Java предоставляет специальный механизм для хранения последовательностей символьных литералов (строк), этот механизм называется - общий пул
строк.
Если две последовательности литералов (строки) имеют одинаковое содержание, то они разделяют общее пространство для хранения внутри общего пула.
Такой подход принят для того, чтобы сохранить место для хранения часто используемых строк. С другой стороны, объекты типа String (строки), созданные с
помощью оператора new и конструктора хранятся в куче.
Коротко о классе String
В Java строки представляют собой неизменяемую последовательность символов Unicode. Они представляют из себя строки литералов, а не строки символьных констант, к которым вы привыкли во время использования языков Си и
Си++. В отличие от представления в C / C ++, где строка является просто массивом типа char, любая строка в Джава является объектом класса java.lang.String.
Здесь нужно заметить, что строки в Джава представляют особенный класс.
В Джава строка, отличие от других используемых классов представляет собой
особый класс, который обладает довольно специфичными характеристиками.
Строка является неизменяемой, то есть, немутабельной (англ. immutable)13.
Это значит, что ее содержание как объекта не может быть изменено после ее создания (создания строки как объекта). Об этом нужно помнить, когда вы работаете со строками и вызываете различные методы класса String. Например, метод
toUpperCase () – преобразования к верхнему регистру создает и возвращает новую строку вместо изменения содержания существующей строки.
Строка в Джава представляет из себя строку литералов (текст), помещенных в двойные кавычки, например: “Hello, World! ”.
Вы можете присвоить последовательность строковых литералов непосредственно переменной типа String, вместо того чтобы вызывать конструктор для
создания экземпляра класса String Оператор ‘+’ одновременно переопределен и
перегружен, для объектов типа String, и всегда используется, чтобы объединить
– конкатенировать две строки в качестве операндов. В данном контексте мы говорим об операции конкатенации или сложения строк (хотя ‘+’ не работает как
оператор сложения для любых других объектов, кроме строк, например, таких
как Point и Circle). Ну конечно он используется с числами? Но не для объектов.

Как видно из рисунка 4.3 есть два способа создания строк:
1) неявное создание путем присвоения строкового литерала переменной
2) явное создание объекта String, через вызов оператора new и вызов
конструктора.
String s1 = "Hello"; // строка литералов
String s2 = "Hello"; // строка литералов String
s3 = s1; // одинаковые ссылки
String s4 = new String("Hello");// String объект
String s5 = new String("Hello");// String объект
Строковые литералы хранятся в общем пуле. Это облегчает совместное использование памяти для строк с тем же содержанием в целях сохранения памяти.
Объекты строк, выделенные с помощью оператора new хранятся в куче (heap), а
там нет разделяемого хранилища для одинакового контента (содержания).

Методы класса String
Класс String содержит множество полезных методов работы со строками
метод, рассмотрим некоторые из них.
Метод, возвращающий длину строки:
int length() // возвращает целое – длину строки
Метод, проверяет пустая ли строка:
boolean isEmpty()
// проверка this.String.length == 0
Метод сравнения двух строк, переопределен для класса String:
boolean equals(String another)
// НЕЛЬЗЯ использовать'==' или'!=' для сравнения объектов String в Java
boolean equalsIgnoreCase(String another)
Метод compareTo() позволяет сравнивать два объекта строки (вы
уже знаете что класс String реализует интерфейс Comparable):
int compareTo(String another) // возвращает 0
если эта строка совпадает с another
Метод сравнения двух строк без учета регистра:
int compareToIgnoreCase(String another)
Поиск в строке подстроки:
boolean startsWith(String another)
Поиск строки, начинающейся с подстроки, начинающейся с индекса
boolean startsWith(String another, int fromIndex)

30. Классы StringBuffer и StringBuilder

JDK предоставляет два класса для поддержки возможностей по изменению
строк: это классы StringBuffer и StringBuilder (входят в основной пакет java.lang
).
StringBuffer используется для многопоточных программ, а класс
StringBuilder для однопоточных программ.
Методы StringBuffer
Для работы с классом нужно импортировать пакет с классом:
java.lang.StringBuffer.
Конструкторы класса StringBuffer
StringBuffer()// инициализация пустой строкой
StringBuffer(int size)
StringBuffer(String s)//инициализируетя
содержимым s

Методы класса StringBuffer
Класс StringBuffer, так же, как и класс String содержит множество полезных методов работы со строками, вот некоторые из них:
int length() //длина строки
Методы для конструирования содержимого строк:
StringBuffer append(type arg)
Методы для манипуляции содержимым строки:
StringBuffer delete(int start, int end)
StringBuffer deleteCharAt(int index)
void setLength(int newSize)
void setCharAt(int index, char newChar)
StringBuffer replace(int start, int end, String
s)
StringBuffer reverse()
Методы для выделения целого/части содержимого
char charAt(int index)
String substring(int start)
String substring(int start, int end)
String toString()
Meтоды для организации поиска в строке:
int indexOf(String searchKey)
int indexOf(String searchKey, int fromIndex)
int lastIndexOf(String searchKey)
int lastIndexOf(String searchKey, int fromIndex)
Обратите внимание, что объект класса StringBuffer является обычным объектом в прямом понимании этого слова. Вам нужно будет использовать конструктор для создания объектов типа класс StringBuffer (вместо инициализации
строки). Кроме того, оператор '+' не применяется к объектам, в том числе и к
объектам StringBuffer. Вы должны будете использовать такой метод, как append()
или insert() чтобы манипулировать StringBuffer . Можно создавать строку из частей.

Пример кода создания строки с помощью методов класса
StringBuffer .
int year = 2010, month = 10, day = 10;
int hour = 10, minute = 10, second = 10;
String dateStr = new StringBuilder().append(year).append("-").append(month).append("").append(day).append("").append(hour)
.apend(":").append(minute).append(":").append(second).toString();
System.out.println(dateStr);
String anotherDataStr = year + "-" + month + "-"
+ day + " " + hour + ":" + minute + ":" + second;
System.out.println(anotherDataStr);
Класс StringBuilder предлагает более эффективную конкатенация строк.
Почему стоит использовать StringBuffer и StringBuilder? Ответ на этот вопрос
прост - объекты StringBuffer или StringBuilder так же, как и любые другие обычные объект хранятся в куче, а не совместно в общем пуле строк.
Следовательно, могут быть изменены, не вызывая нехороших побочных
эффектов на другие объекты.

31.Регулярные выражения и их использование в Java
программах для обработки строк

Регулярные выражения – эта система обработки текста, основанная
на специальной системе записи образцов для поиска. Образец (pattern),
задающий правило поиска, по-русски также иногда называют «шаблоном»,
«маской». Сейчас регулярные выражения используются многими
текстовыми редакторами и утилитами для поиска и изменения текста на
основе выбранных правил. Язык программирования Java также
поддерживает регулярные выражения для работы со строками.
Основными классами для работы с регулярные выражения являются
класс java.util.regex.Pattern и класс java.util.regex.Matcher.
Для определения шаблона применяются специальные синтаксические
конструкции.
Класс Pattern
Класс java.util.regex.Pattern применяется для определения регулярных
выражений, для которого ищется соответствие в строке, файле или другом
объекте представляющем собой некоторую последовательность символов.
Этот класс используется для простой обработки строк. Для более сложной
обработки строк используется класс Matcher, рассматриваемый ниже.
В классе Pattern объявлены следующие методы:
• compile(String regex) – возвращает Pattern, который соответствует
regex;
• matcher(CharSequence input) – возвращает Matcher, с помощью
которого можно находить соответствия в строке input;
• matches(String regex, CharSequence input) – проверяет на соответствие
строки input шаблону regex;
• pattern() – возвращает строку, соответствующую шаблону;
• split(CharSequence input) – разбивает строку input, учитывая, что
разделителем является шаблон;
• split(CharSequence input, int limit) – разбивает строку input на не более
чем limit частей.
С помощью метода matches() класса Pattern можно проверять на
соответствие шаблону целой строки, но если необходимо найти
соответствия внутри строки, например, определять участки, которые
соответствуют шаблону, то класс Pattern не может быть использован. Для
таких операций необходимо использовать класс Matcher.

Класс Matcher
С помощью класса java.util.regex.Matcher можно получить больше
информации каждом соответствии.
Начальное состояние объекта типа Matcher не определено. Попытка
вызвать какой-либо метод класса для извлечения информации о найденном
соответствии приведет к возникновению ошибки IllegalStateException. Для
того чтобы начать работу с объектом Matcher нужно вызвать один из его
методов:
• matches() – проверяет, соответствует ли вся строка шаблону;
• lookingAt() – пытается найти последовательность символов,
начинающуюся с начала строки и соответствующую шаблону;
• find() или find(int start) – пытается найти последовательность
символов, соответствующих шаблону, в любом месте строки.
Параметр start указывает на начальную позицию поиска.
Иногда необходимо сбросить состояние объекта класса Matcher в
исходное, для этого применяется метод reset() или reset(CharSequence input),
который также устанавливает новую последовательность символов для
поиска.
Для замены всех подпоследовательностей символов,
удовлетворяющих шаблону, на заданную строку можно применить метод
replaceAll(String replacement).
Для того чтобы ограничить поиск границами входной
последовательности применяется метод region(int start, int end), а для
получения значения этих границ – regionEnd() и regionStart(). С регионами
связано несколько методов:
useAnchoringBounds(boolean b) – если установлен в true, то начало и
конец региона соответствуют символам ^ и $ соответственно;
hasAnchoringBounds() – проверяет закрепленность границ.
В регулярном выражении для более удобной обработки входной
последовательности применяются группы, которые помогают выделить
части найденной подпоследовательности. В шаблоне они обозначаются
скобками «(» и «)». Номера групп начинаются с единицы. Нулевая группа
совпадает со всей найденной подпоследовательностью. Далее приведены
методы для извлечения информации о группах:
end() – возвращает индекс последнего символа
подпоследовательности, удовлетворяющей шаблону;
end(int group) – возвращает индекс последнего символа указанной
группы;
group() – возвращает всю подпоследовательность, удовлетворяющую
шаблону;
group(int group) – возвращает конкретную группу;
groupCount() – возвращает количество групп;
start() – возвращает индекс первого символа подпоследовательности,
удовлетворяющей шаблону;
start(int group) – возвращает индекс первого символа указанной
группы;
hitEnd() – возвращает истину, если был достигнут конец входной
последовательности.
Следующий пример показывает использование возможностей
классов Pattern и Matcher, для поиска, разбора и разбиения строк.

Пример использования классов Pattern и Matcher,
import java.util.regex.*;
public class DemoRegular {
public static void main(String[] args) {
// проверка на соответствие строки шаблону
Pattern p1 = Pattern.compile("a*y");
Matcher m1 = p1.matcher( "aaay" );
boolean b = m1.matches();
System.out.println(b);
// поиск и выбор подстроки, заданной шаблоном
String regex = "(\\w+)@(\\w+\\.)(\\w+)(\\.\\w+)*" ;
String s = "адреса эл.почты: mymail@tut.by и
rom@bsu.by";
Pattern p2 = Pattern. compile (regex);
Matcher m2 = p2.matcher(s);
while (m2.find()) {
System.out.println("e-mail: " + m2.group());
}
// разбиение строки на подстроки с применением
шаблона в качестве
// разделителя
Pattern p3 = Pattern.compile("\\d+\\s?");
String[] words = p3.split("java5tiger 77
java6mustang");
for (String word : words)
System.out.println(word);
}
}}
В результате работы программы будет выведено:
true
e - mail : mymail @ tut. by
e-mail: rom@bsu.by
java
tiger
java
mustang

Следующий пример демонстрирует возможности использования
групп, а также собственных и неполных квантификаторов.
Листинг 14.2 – Пример использования квантификаторов
import java.util.regex.*;
public class Groups {
public static void main(String[] args) {
String input = "abdcxyz";
myMatches("([a-z]*)([a-z]+)", input);
myMatches("([a-z]?)([a-z]+)", input);
myMatches("([a-z]+)([a-z]*)", input);
}}
В результате работы программы будет выведено:
First group: abdcxy
Second group: z
First group: a
Second group: bdcxyz
First group: abdcxyz
Second group: nothing
В первом случае к первой группе (First group) относятся все
возможные символы, но при этом остается минимальное количество
символов для второй группы (Second group). Во втором случае для первой
группы выбирается наименьшее количество символов, т. к. используется
слабое совпадение. В третьем случае первой группе будет соответствовать
вся строка, а для второй не остается ни одного символа, так как вторая
группа использует слабое совпадение. В четвертом случае строка не
соответствует регулярному выражению, т. к. для двух групп выбирается
наименьшее количество символов.
В классе Matcher объявлены два полезных метода для замены
найденных подпоследовательностей во входной строке.
Matcher appendReplacement(StringBuffer sb, String replacement) –
метод читает символы из входной стоки и добавляет их в sb. Чтение
останавливается на start() – первой позиции предыдущего совпадения,
после чего происходит добавление в sb строки replacement. При следующем
вызове этого метода, производится добавление символов, начиная с
символа с индексом end() предыдущего совпадения.

Класс StringTokenizer
Этот класс предназначен для разбора строки по лексемам (tokens).
Строка которую необходимо разобрать передается в качестве параметра
конструктору StringTokenizer(String str). Определено еще два
перегруженных конструктора, которым дополнительно можно передать
строку-разделитель лексем StringTokenizer(String str,String delim) и признак
возврата разделителя лексем StringTokenizer(String str,String delim,Boolean
retirnDelims). Разделителем лексем по умолчанию служит пробел.
Листинг 14.3 – Пример класса Test
public class Test {
 public Test() {
}
public static void main(String[] args) {
Test test = new Test();
String toParse = “word1;word2;word3;word4”;
StringTokenizer st = new
StringTokenizer(toParse,";");
while(st.hasMoreTokens()){
System.out.println(st.nextToken());
}
}
}
Вывод:
word1
word2
word3
word4

32. Вложенные классы
В Java вложенные классы — это классы, которые определены внутри
другого класса. Цель вложенного класса - четко сгруппировать вложенный
класс с окружающим его классом, сигнализируя, что эти два класса должны
использоваться вместе. Или, возможно, вложенный класс должен
использоваться только изнутри его включающего (владеющего) класса.
Разработчики на Джава часто ссылаются на вложенные классы в качестве
внутренних классов, но внутренние классы (нестатические вложенные
классы) только один из нескольких различных типов вложенных классов в
Джава. В Джава вложенные классы считаются компонентами своего
включающего класса. Таким образом, вложенный класс не может быть
объявлен public, package (без модификатора доступа), protected и private (см.
модификаторов доступа для получения дополнительной информации).
Следовательно, вложенные классы в Джава также могут наследоваться
подклассами. В Джава можно создать несколько различных типов
вложенных классов.
Рассмотрим различные типы вложенных классов Java:
• Статические вложенные классы
• Нестатические вложенные классы
• Местные классы
• Анонимные классы

Статические вложенные классы
Статические вложенные классы объявляются в Java следующим
образом:
public class Outer {
 public static class Nested {
 }}
Чтобы создать экземпляр Nested класса, вы должны сослаться на
него, добавив к нему префикс имени Outer класса, например:
Outer.Nested instance = new Outer.Nested ();
Листинг 15.1 – Пример класса Question
public class Question {
 private Type type;
 public Type getType() { return type; }
 public void setType(Type type) { this.type = type;
}
 public static enum Type {
 SINGLE_CHOICE, MULIT_CHOICE, TEXT
 }
}
В языке Джава статический вложенный класс — это, по сути,
обычный класс, который только что был вложен в другой класс. Будучи
статическим, статический вложенный класс может получить доступ только
к переменным экземпляра включающего класса через ссылку на экземпляр
включающего класса.

Нестатические вложенные классы
Нестатические вложенные классы в Java также называются
внутренними классами. Внутренние классы связаны с экземпляром
включающего класса. Таким образом, вы должны сначала создать
экземпляр включающего класса, чтобы создать экземпляр внутреннего
класса. Вот пример определения внутреннего класса:
public class Outer {
 public class Inner { //вложенный класс
 }
}
Вот как вы создаете экземпляр Inner класса:
Outer outer = new Outer();
Outer.Inner inner = outer.new Inner();
Обратите внимание, как вы ставите new после ссылки на внешний
класс, чтобы создать экземпляр внутреннего класса. нестатические
вложенные классы (внутренние классы) имеют доступ к полям
включающего класса, даже если они объявлены закрытыми. Вот пример:
Листинг 15.2 – Пример внутреннего (иннер) класса
public class Outer {
 private String text = "I am private!";
 public class Inner {
 public void printText() {
 System.out.println(text);
 }
 }
}
Вложенные классы делятся на статические (в примере выше
StaticNestedClass — это именно такой класс) и нестатические (non-static).
Собственно нестатические вложенные классы имеют и другое
название - внутренние классы (inner classes). Внутренний класс (inner)
является подмножеством вложенного класса (nested classes). Внешний класс
(outer class) мы иногда будем называть еще обрамляющим классом.

Локальные классы (local inner classes)
Локальные классы (local classes) определяются в блоке кода в
программе на языке Джаве. На практике чаще всего объявление происходит
в методе некоторого другого класса. Хотя объявлять локальный класс
можно внутри статических и нестатических блоков инициализации. Пример
использования локального класса:
Листинг 15.3 – Пример локального класса
Public class Handler {
Public void handle(String requestPath){
сlass Path{
List<String> parts = new ArrayList<String>();
String path = "/";
Path(String path) {
if (path == null) return;
this.path = path;
for (String s : path.split("/"))
if(s.trim().length() > 0) this.parts.add(s);
}
int size(){return parts.size();}
String get(int i){
return i > this.parts.size() – 1 ? null :
this.parts.get(i);
}
boolean startsWith(String s){
return path.startsWith(s);
}
 }
Path path = new Path(requestPath);
if(path.startsWith("/page")){
String pageId = path.get(1);
... }
if(path.startsWith("/post")){
 categoryId = path.get(1);
 String postId = path.get(2);
...
}
...
}}
Данный код с некоторыми изменениями взят из реального проекта и
используется для обработки get запросов к веб-серверу. Он вводит новую
абстракцию, с которой удобно работать в пределах метода и которая не
нужна за его пределами.
Как и обычный поля классы, локальные классы ассоциируются с
экземпляром обрамляющего класса и имеют доступ к его полям и методам.
Кроме этого, локальный класс может обращаться к локальным переменным
и параметрам метода, если они объявлены с модификатором final.
У локальных классов есть множество ограничений:
• они видны только в пределах блока, в котором объявлены;
• они не могут быть объявлены как private, public, protected или static;
• они не могут иметь внутри себя статических объявлений (полей,
методов, классов); исключением являются константы (static final);
Кстати, интерфейсы тоже нельзя объявлять локально по тем же
причинам, по каким их нельзя объявлять внутренними.

33. Анонимные классы (anonymous inner classes)

Анонимные классы являются важным подспорьем в повседневной
жизни программистов на языке Джава. Анонимный класс (anonymous
class) — это локальный класс без имени. Классический пример
анонимного класса:
 new Thread(new Runnable() {
 public void run() {
 ...
 }
 }).start();
На основании анонимного класса создается поток и запускается с
помощью метода start класса Thread. Синтаксис создания анонимного
класса базируется на использовании оператора new с именем класса
(интерфейса) и телом вновь создаваемого анонимного класса.
Основное ограничение при использовании анонимных классов — это
невозможность описания конструктора, так как класс не имеет имени.
Аргументы, указанные в скобках, автоматически используются для вызова
конструктора базового класса с теми же параметрами. Вот пример:
Листинг 15.4 – Пример анонимного класса
Class Clazz {
Clazz(int param) { }
Public static void main(String[] args){
// правильное создание анонимного класса
New Clazz(1) { };
// неправильное создание анонимного класса
New Clazz() { };
}}
Так как анонимный класс является локальным классом, он имеет все
те же ограничения, что и локальный класс.
Использование анонимных классов оправдано во многих случаях, в
частности когда:
• тело класса является очень коротким;
• нужен только один экземпляр класса;
• класс используется в месте его создания или сразу после него;
• имя класса не важно и не облегчает понимание кода.
Остается только сказать, что нужно использовать с умом
возможности, которые предоставляют нам вложенные классы, это сделает
ваш код чище, красивее и понятнее.

Преимущества использования вложенного класса
Преимущества вложенных классов в языке Джава заключаются в том,
что вы можете группировать классы вместе, которые принадлежат друг
другу. Вы, конечно, можете группировать их, например поместив в один
пакет, но размещение одного класса внутри другого делает такую
группировку более сильной.
Вложенный класс, как правило, используется только через класс, в
который он вложен. Иногда вложенный класс виден только классу, в
который он вложен, используется только внутри и, следовательно, никогда
не виден за пределами этого класса. В других случаях вложенный класс
виден за пределами класса, в который он вложен, но не может
использоваться без него

34. Обработка событий в программах с графическим
интерфейсом пользователя
Что означает термин обработка событий? В Джава это механизм,
который контролирует состояние объекта на предмет наступления события
и при его появлении запускает процедуру обработки события. В качестве
объектов выступают различные компоненты графического интерфейса,
например кнопки или текстовые поля. Это также может быть курсор мыши,
нажатие кнопки мыши или нажатие клавиши клавиатуры. То есть, объекты
gui это источники событий. Для каждого объекта создаётся слушатель
события с помощью специального класса. Слушатель при наступлении
события запускает процедуру обработки события.

Интерфейс ActionListener
В Джава есть интерфейс ActionListener. Он получает уведомление
всякий раз, когда вы нажимаете кнопку или выбираете пункт меню. Он
уведомлен о наступлении события ActionEvent. Интерфейс ActionListener
находится в пакете java.awt.event . У него только один метод:
actionPerformed (). При создании собственного обработчика вам нужно
добавить в свой класс реализацию этого метода.

Метод actionPerformed ()
Синтаксис метода:
public abstract void actionPerformed (ActionEvent
e);
Метод actionPerformed () вызывается автоматически всякий раз, когда
вы изменяете состояние объекта, например щелкаете мышкой по кнопке.
Как написать ActionListener в своем классе. Для этого вам необходимо
выполнить 3 шага:
1.Реализуйте интерфейс ActionListener в классе:
public class ActionListenerExample implements
ActionListener
2. Зарегистрируйте компонент в Listener (component здесь это тот
компонент для которого пишете):
component.addActionListener(instanceOfListenercla
ss);
3. Переопределите метод actionPerformed ()
public void actionPerformed(ActionEvent e){
//Здесь пишете свой код
}
Листинг 15.5 – Пример обработки нажатия на кнопку
import java.awt.*;
import java.awt.event.*;
//первый шаг
public class ActionListenerExample implements
ActionListener{
public static void main(String[] args) {
 Frame f=new Frame("ActionListener Example");
 final TextField tf=new TextField();
 tf.setBounds(50,50, 150,20);
 Button b=new Button("Click Here");
 b.setBounds(50,100,60,30);
 //второй шаг
 b.addActionListener(this);
 f.add(b);f.add(tf);
 f.setSize(400,400);
 f.setLayout(null);
 f.setVisible(true);
}
//третий шаг
public void actionPerformed(ActionEvent e){
 tf.setText("Добро пожаловать в мир
Джава.");
}
}

Использование анонимных классов
Рассмотрим пример реализации ActionListener через анонимный
класс:
Мы также можем использовать анонимный класс для реализации
ActionListener, вместо способа, рассмотренного в листинге 15.1 Это
сокращенный способ, поэтому вам теперь не нужно выполнять все три шага
описанные выше. Добавляем слушателя к кнопке таким образом:
b.addActionListener ( новый ActionListener () {
public void actionPerformed (ActionEvent e) {
 tf.setText ( «Добро пожаловать в мир Java.»
);
}
});

35.Обработка событий мыши и
клавиатуры программах на Джава с графическим
интерфейсом пользователя

Механизм обработки событий библиотеки Swing
В контексте графического интерфейса пользователя наблюдаемыми
объектами являются элементы управления: кнопки,флажки, меню и т.д.
Они могут сообщить своим наблюдателям об определенных событиях, как
элементарных (наведение мышкой, нажатие клавиши на клавиатуре), так и
о высокоуровневых (изменение текста в текстовом поле, выбор нового
элемента в выпадающем списке и т.д.).
Наблюдателями должны являться объекты классов,
поддерживающих специальные интерфейсы (в классе наблюдателя должны
быть определенные методы, о которых «знает» наблюдаемыйи вызывает их
при наступлении события). Такие классы в терминологии Swing
называются слушателями.
Интерфейс MouseListener и обработка событий от мыши
События от мыши — один из самых популярных типов событий.
Практически любой элемент управления способен сообщить о том,
что на него навели мышь, щелкнули по нему и т.д. Об этом будут
оповещены все зарегистрированные слушатели событий от мыши.
Слушатель событий от мыши должен реализовать интерфейс
MouseListener. В этом интерфейсе перечислены следующие методы:
• public void mouseClicked(MouseEvent event) — выполнен
щелчок мышкой на наблюдаемом объекте
• public void mouseEntered(MouseEvent event) — курсор мыши
вошел в область наблюдаемого объекта
• public void mouseExited(MouseEvent event) — курсор мыши
вышел из области наблюдаемого объекта
• public void mousePressed(MouseEvent event) — кнопка мыши
нажата в момент, когда курсор находится над наблюдаемым объектом
• public void mouseReleased(MouseEvent event) — кнопкамыши

отпущена в момент, когда курсор находится наднаблюдаемым объектом
Чтобы обработать нажатие на кнопку, требуется описать класс,
реализующий интерфейс MouseListener. Далее необходимо создать объект
этого класса и зарегистрировать его как слушателя интересующей нас
кнопки. Для регистрации слушателя используется метод
addMouseListener().
Опишем класс слушателя в пределах класса окна SimpleWindow,
после конструктора. Обработчик события будет проверять, ввел ли
пользователь логин «Иван» и выводить сообщение об успехе или неуспехе
входа в систему:
class MouseL implements MouseListener {
public void mouseClicked(MouseEvent event) { if
(loginField.getText().equals("Иван"))
JOptionPane.showMessageDialog(null, "Вход
выполнен"); else
JOptionPane.showMessageDialog(null, "Вход НЕ
выполнен");
}
public void mouseEntered(MouseEvent event) {}
public void mouseExited(MouseEvent event) {} public
void mousePressed(MouseEvent event) {} public void
mouseReleased(MouseEvent event) {}
}
Мы сделали слушателя вложенным классом класса SimpleWindow,
чтобы он мог легко получить доступ к его внутреннимполям loginField и
passwordField. Кроме того, хотя реально мы обрабатываем только одно из
пяти возможных событий мыши, описывать пришлось все пять методов
(четыре имеют пустую реализацию). Дело в том, что в противном случае
класс пришлось бы объявить абстрактным (ведь он унаследовал от
интерфейса пустые заголовки методов) и мы не смогли бы создать объект
этого класса. Амы должны создать объект слушателя и прикрепить его к
кнопке. Дляэтого в код конструктора SimpleWindow() необходимо добавить
команду:
ok.addMouseListener(new MouseL());
Это можно сделать сразу после команды:
JButton ok = new JButton("OK");
Создание слушателей с помощью анонимных классов. Чтобы кнопка
ok обрела слушателя, который будет обрабатывать нажатие на нее, нам
понадобилось описать новый (вложенный) класс. Иногда вместо
вложенного класса можно обойтись анонимным. Анонимный класс не
имеет имени и в программе, может быть, создан только один объект этого
класса (создание которого совмещено с определением класса). Но очень
часто слушатель пишется для того, чтобы обрабатывать события
единственного объекта — в нашем случае кнопки ok, а значит, используется
в программе только однажды: во время привязки к этому объекту. Таким
образом, мы можем заменить вложенный класс анонимным. Для этого
описание класса MouseL можно просто удалить, а команду
ok.addMouseListener(new MouseL());заменить на:
ok.addMouseListener(new MouseListener() {
public void mouseClicked(MouseEvent event) { if
(loginField.getText().equals("Иван"))
JOptionPane.showMessageDialog(null, "Вход
выполнен");
else JOptionPane.showMessageDialog(null, "Вход НЕ
выполнен");
}
public void mouseEntered(MouseEvent event) {}
public void mouseExited(MouseEvent event) {} public
void mousePressed(MouseEvent event) {} public void
mouseReleased(MouseEvent event) {}
});
Новый вариант выглядит более громоздко, чем первый.
Злоупотребление анонимными классами может сделать программу
плохо читаемой. Однако в результате все действия с кнопкой (создание,
настройка ее внешнего вида и команды обработки щелчка по ней) не
разнесены, как в случае вложенных классов, а находятся рядом, что
облегчает сопровождение (внесение изменений) программы. В случае
простых (в несколько строк) обработчиков разумно делать выбор в пользу
анонимных классов.

36.паттерна MVC

Шаблон проектирования в программной инженерии — это метод
решения часто возникающей проблемы при разработке программного
обеспечения. Проектирование по модели указывает, какой тип архитектуры
вы используете для решения проблемы или разработки модели.
Существует два типа моделей проектирования:
• архитектура модели 1
• архитектура модели 2 (MVC).
Архитектура MVC в Джава приложениях
Проекты моделей, основанные на архитектуре MVC (model-viewcontroller), следуют шаблону проектирования MVC и отделяют логику
приложения от пользовательского интерфейса при разработке
программного обеспечения.
Как следует из названия, шаблон MVC имеет три уровня:
• Модель — представляет бизнес-уровень приложения (model).
• Вид — определяет представление приложения (view).
• Контроллер — управляет потоком приложения (controller).
В контексте программирования модель на Java состоит из простых
классов Java, уровень представление отображает данные – то что видит
пользователь, а контроллер состоит из сервлетов. Это разделение приводит
к тому, что запросы пользователей обрабатываются следующим образом:
1. Браузер на клиенте отправляет запрос на страницу контроллеру,
присутствующему на сервере.
2. Контроллер выполняет действие по вызову модели, тем самым
извлекая необходимые ему данные в ответ на запрос.
3. Затем контроллер передает полученные данные в представление.
4. Представление визуализируется и отправляется обратно клиенту для
отображения в браузере.
Разделение программного приложения на эти три отдельных
компонента является хорошей идей по ряду причин.

Архитектура MVC предлагает множество преимуществ для
программиста при разработке приложений, в том числе:
• Несколько разработчиков могут одновременно работать с тремя
уровнями (модель, представление и контроллер).
• Предлагает улучшенную масштабируемость , которая дополняет
возможность роста приложения.
• Поскольку компоненты мало зависят друг от друга, их легко
поддерживать.
• Модель может быть повторно использована несколькими
представлениями, что обеспечивает возможность повторного
использования кода.
• Применение MVC делает приложение более выразительным и
простым для понимания.
• Расширение и тестирование приложения становится проще
Шаблон MVC является самым популярным шаблоном
проектирования для веб разработки.

Чтобы реализовать веб-приложение на основе шаблона
проектирования MVC, мы создадим следующие классы:
• Класс Course, который действует как слой модели
• Класс CourseView, определяющий уровень представления
(слой представления)
• Класс CourseContoller, который действует как контроллер
Уровень слоя модели
В шаблоне проектирования модель MVC представляет собой уровень
данных, который определяет бизнес-логику системы, а также представляет
состояние приложения. Объекты модели извлекают и сохраняют состояние
модели в базе данных. На этом уровне мы применяем правила к данным,
которые в конечном итоге представляют концепции, которыми управляет
наше приложение. Теперь давайте создадим модель с помощью класса
Course см листинг 17.1

package myPackage;
public class Course {
 private String CourseName;
 private String CourseId;
 private String CourseCategory;
 public String getId() {
 return CourseId;
 }
 public void setId(String id) {
 this.CourseId = id;
 }
 public String getName() {
 return CourseName;
 }
 public void setName(String name) {
 this.CourseName = name;
 }
 public String getCategory() {
 return CourseCategory;
 }
 public void setCategory(String category) {
 this.CourseCategory = category;
 }
}

package myPackage;
public class CourseView {
 public void printCourseDetails(String CourseName,
String CourseId, String CourseCategory){
 System.out.println("Course Details: ");
 System.out.println("Name: " + CourseName);
 System.out.println("Course ID: " + CourseId);
 System.out.println("Course Category: " +
CourseCategory);
 }
}

package myPackage;
public class CourseController {
 private Course model;
 private CourseView view;
 public CourseController(Course model, CourseView
view){
 this.model = model;
 this.view = view;
 }
 public void setCourseName(String name){
 model.setName(name);
 }
 public String getCourseName(){
 return model.getName();
 }
 public void setCourseId(String id){
 model.setId(id);
 }
 public String getCourseId(){
 return model.getId();
 }
 public void setCourseCategory(String category){
 model.setCategory(category);
 }
 public String getCourseCategory(){
 return model.getCategory();
 }
 public void updateView(){
 view.printCourseDetails(model.getName(),
model.getId(), model.getCategory());
 }
}

Теперь соединим
все вместе, для этого напишем тестовый класс, назовем его
MVCPatternDemo.java.

package myPackage;
public class MVCPatternDemo {
 public static void main(String[] args) {
 //fetch student record based on his roll no
from the database
 Course model = retriveCourseFromDatabase();
 //Create a view : to write course details on
console
 CourseView view = new CourseView();
 CourseController controller = new
CourseController(model, view);
 controller.updateView();
 //update model data
 controller.setCourseName("Python");
 System.out.println("nAfter updating, Course
Details are as follows");
 controller.updateView();
 }
 private static Course
retriveCourseFromDatabase(){
 Course course = new Course();
 course.setName("Java");
 course.setId("01");
 course.setCategory("Programming");
 return course;
 }
}
}
Приведенный на листинге класс извлекает данные курса из функции
с помощью которой пользователь вводит набор значений. Затем он
помещает эти значения в модель курса. Затем он инициализирует новое
представление, которое мы создали ранее. Кроме того, он также вызывает
класс CourseController и связывает его с классом Course и классом
CourseView, метод updateView() , который является частью контроллера,
затем обновляет сведения о курсе на консоли.

Вывод. Архитектура MVC обеспечивает совершенно новый уровень
модульности вашего кода, что делает его более читабельным и удобным в
сопровождении.

37. Исключения try/catch/finally
Механизм исключительных ситуаций в Java поддерживается пятью
ключевыми словами:
• try
• catch
• finally
• throw
• throws
В языке Джава Java всего около 50 ключевых слов, и пять из них
связано как раз с исключениями, это- try, catch, finally, throw, throws.
Из них catch, throw и throws применяются к экземплярам класса,
причём работают они только с Throwable и его наследниками.
То, что исключения являются объектами важно по двум причинам:
1) они образуют иерархию с корнем java.lang.Throwable
(java.lang.Object — предок java.lang.Throwable, но Object —это
не исключение!)
2) они могут иметь поля и методы
По первому пункту: catch — полиморфная конструкция, т.е. catch по
типу класса родителя перехватывает исключения для экземпляров объектов
как родительского класса, так или его наследников(т.е. экземпляры
непосредственно самого родительского класса или любого его потомка).
Пример обработки исключения
public class App {
 public static void main(String[] args) {
 try {
 System.err.print(" 0");
 if (true) {throw new
RuntimeException();}
 System.err.print(" 1");
 } catch (Exception e) { // catch по
Exception ПЕРЕХВАТЫВАЕТ RuntimeException
 System.err.print(" 2");
 }
 System.err.println(" 3");
 }// end main
}
Результат работы программы: представленной на листинге 18.1:
>> 0 2 3

Язык Java предоставляет исчерпывающий набор классов исключений,
но иногда при разработке программ вам потребуется создавать новые – свои
собственные исключения, которые являются специфическими для
потребностей именно вашего приложения. В этой практической работе вы
научитесь создавать свои собственные пользовательские классы
исключений. Как вы уже знаете, в Java есть два вида исключенийпроверяемы и непроверяемые. Для начала рассмотрим создание
пользовательских проверяемых исключений.

Создание проверяемых пользовательских исключений
Проверяемые исключения — это исключения, которые необходимо
обрабатывать явно. Рассмотрим пример кода:
Листинг 19.1 Пример обработки исключения
try (Scanner file = new Scanner(new
File(fileName))){
 if (file.hasNextLine()) return file.nextLine();
} catch(FileNotFoundException e) {
 // Logging, etc
}
Приведенный на листинге 19.1 код является классическим способом
обработки проверяемых исключений на Java. Хотя код выдает исключение
FileNotFoundException, но в целом неясно, какова точная причина ошибки
– не такого файла нет или же имя файла является недопустимым.
Чтобы создать собственное пользовательское исключение, мы будем
наследоваться от класса java.lang.Exception. Давайте рассмотрим пример
как это реализуется на практике и создадим собственный класс для
проверяемого исключения с именем BadFileNameException:

Пример класса исключения
public class BadFileNameException extends
Exception {
 public BadFileNameException(String
errorMessage){
 super(errorMessage);
 }
}
Обратите внимание, что мы также должны написать конструктор в
нашем классе, который принимает параметр типа String в качестве
сообщения об ошибке, в котором вызывается конструктор родительского
класса. Фактически это все, что нам нужно сделать, чтобы определить свое
собственное пользовательское исключение.
Далее, давайте посмотрим, как мы можем использовать
пользовательское исключение в программе

Пример генерации исключения из за неправильного имени
файла
try (Scanner file = new Scanner(new
File(fileName))){
 if (file.hasNextLine())
 return file.nextLine();
} catch (FileNotFoundException e) {
 if (!isCorrectFileName(fileName)) {
 throw new BadFileNameException("Bad
filename : " + fileName );
 }
 //...
}
Мы создали и использовали свое собственное пользовательское
исключение, теперь в случае ошибки, можно понять, что произошло, и
какое именно исключение сработало. Как вы думаете, этого достаточно?
Если ваш ответ да, то мы не узнаем основную причину, по которой
сработало исключения. Как исправить программу. Для этого мы также
можем добавить параметр java.lang.Throwable в конструктор. Таким
образом, мы можем передать родительское исключение во время вызова
метода:
 Пример использования исключения
public BadFileNameException(String errorMessage,
Throwable err) {
 super(errorMessage, err);
}
Теперь мы связали BadFileNameException с основной причиной
возникновения данного исключения, например:
Листинг 19.5 Пример обработки исключительной ситуации некорректного
имени файла
try (Scanner file = new Scanner(new
File(fileName))){
 if (file.hasNextLine()) {
 return file.nextLine();
 }
} catch (FileNotFoundException err) {
 if (!isCorrectFileName(fileName)) {
 throw new BadFileNameException(
 "Bad filename: " + fileName, err);
 }
 // ...
}
Мы рассмотрели, как мы можем использовать пользовательские
исключения в программах, учитывая их связь с причинами по которым они
могут возникать.

Создание непроверяемых пользовательских исключений
В том же примере, который мы рассматривали выше предположим,
что нам нужно такое пользовательское исключение, в котором
обрабатывается ошибка, если файла не содержит расширения.
В этом случае нам как раз понадобится создать пользовательское
непроверяемое исключение, похожее на предыдущее, потому что данная
ошибка будет обнаружена только во время выполнения участка кода.
Чтобы создать собственное непроверяемое исключение, нам нужно
наследоваться от класса java.lang.RuntimeException:
Листинг 19.6 Пример создания пользовательского класса исключения
public class BadFileExtensionException
 extends RuntimeException {
 public BadFileExtensionException(String
errorMessage, Throwable err) {
 super(errorMessage, err);
 }
}
Теперь, мы можем использовать это нестандартное исключение в
рассматриваемом нами выше примере:
Листинг 19.7 Пример использования нестандартного исключения
try (Scanner file = new Scanner(new
File(fileName))){
 if (file.hasNextLine()) {
 return file.nextLine();
 } else {
 throw new IllegalArgumentException("Non
readable file");
 }
} catch (FileNotFoundException err) {
 if (!isCorrectFileName(fileName)) {
 throw new BadFileNameException(
 "Bad filename: " + fileName , err);
 }

 //...
} catch(IllegalArgumentException err) {
 if(!containsExtension(fileName)) {
 throw new BadFileExtensionException(
 "Filename does not contain extension: "
+ fileName, err);
 }

 //...
}
Заключение
В приведенных выше примерах мы рассмотрели основные
особенности обработки исключений.

38.Дженерики

В JDK представлены дженерики (перевод с
англ. generics), которые поддерживают абстрагирование по типам (или
параметризованным типам). В объявлении классов дженерики
представлены обобщенными типами, в то время как пользователи классов
могут быть конкретными типами, например во время создания объекта или
вызова метода.
Вы, конечно, знакомы с передачей аргументов при вызове методов в
языке С++. Когда вы передаете аргументы внутри круглых скобок () в
момент вызова метода, то аргументы подставляются вместо формальных
параметров с которыми объявлен и описан метод. Схожим образом в
generics вместо передаваемых аргументов мы передаем информацию
только о типах аргументов внутри угловых скобок <> (так называемая
diamond notation или алмазная запись).
Основное назначение использования дженериков — это абстракция
работы над типами при работе с коллекциями («Java Collection
Framework»).
Например, класс ArrayList можно представить следующим образом
для получения типа дженериков <E> следующим образом:
Класс ArrayList с параметризованным типом E
public class ArrayList<E> implements List<E> ....
{
 //конструктор
 public ArrayList() { ...... }
 // методы public
 public boolean add(E e) { ...... }
 public void add(int index, E element) { ......
}
 public boolean addAll(int index, Collection<?
extends E> c)
 public abstract E get(int index) { ...... }
 public E remove(int index)
 .......
}
Чтобы создать экземпляр ArrayList, пользователям необходимо
предоставить фактический тип для <E> для данного конкретного
экземпляра. Фактический тип будет заменять все ссылки на E внутри
класса. Например:
Листинг 20.2 Пример создания экземпляра класса ArrayList с типом Integer
ArrayList<Integer> lst1 = new
ArrayList<Integer>();
// E подстановка Integer
lst1.add(0, new Integer(88));
lst1.get(0);
ArrayList<String> lst2 = new ArrayList<String>();
// E подстановка String
lst2.add(0, "Hello");
lst2.get(0);
В приведенном выше примере показано, что при проектировании или
определении классов, они могут быть типизированными по общему типу; в
то время как пользователи классов предоставляют конкретную
фактическую информацию о типе во время создания экземпляра объекта
типа класс. Информация о типе передается внутри угловых скобок <>, так
же как аргументы метода передаются внутри круглой скобки ().
В этом плане общие коллекции не являются безопасными типами!
Если вы знакомы с классами- коллекциями, например, такими как
ArrayList, то вы знаете, что они предназначены для хранения объектов типа
java.lang.Object. Используя основной принцип ООП-полиморфизм, любой
подкласс класса Object может быть заменен на Object. Поскольку Object
является общим корневым классом всех классов Java, то коллекция,
предназначенная для хранения Object, может содержать любые классы Java.
Однако есть одна проблема. Предположим, например, что вы хотите
определить ArrayList из объектов класса String. То при выполнении
операций, например операции add(Object) объект класса String будет
неявным образом преобразовываться в Object компилятором. Тем не менее,
во время поиска ответственность программиста заключается в том, чтобы
явно отказаться от Object обратно в строку. Если вы непреднамеренно
добавили объект не-String в коллекцию, то компилятор не сможет
обнаружить ошибку, а понижающее приведение типов (от родителя к
дочернему) завершится неудачно во время выполнения (будет
сгенерировано ClassCastException throw).
Ниже приведен пример:
Листинг 20.3 Пример использования интерфейсной ссылки List для
инициализации объектом класса ArrayList
import java.util.*;
public class ArrayListWithoutGenericsTest {
 public static void main(String[] args) {
 List strLst = new ArrayList();
// List и ArrayList содержит тип Objects
 strLst.add("alpha");
// Неявное преобразование String в Object
 strLst.add("beta");
 strLst.add("charlie");
 Iterator iter = strLst.iterator();
 while (iter.hasNext()) {
 String str = (String)iter.next();
// необходимо выполнить понижающее преобразование
типов Object обратно в String
 System.out.println(str);
 }
 strLst.add(new Integer(1234));
// на этапе Compile/runtime невозможно определить
ошибку
 String str = (String)strLst.get(3);
// компиляция ok, но будет runtime
ClassCastException
 }
}
Замечание. Мы могли бы использовать оператор создания объектов
типа класс для проверки правильного типа перед добавлением. Но опять же,
при создании объектов (инстанцировании) проблема обнаруживается во
время выполнения. Как насчет проверки типа во время компиляции?

Давайте напишем наш собственный «безопасный тип» ArrayList
Мы проиллюстрируем использование дженериков путем написания
нашего собственного типа изменяемого размера массива для хранения
определенного типа объектов (аналогично ArrayList).
Начнем с версии MyArrayList без дженериков:

public class MyArrayList {
 private int size;
// количество элементов – размер коллекции
 private Object[] elements;

 public MyArrayList() {
//конструктор
 elements = new Object[10];
// начальная инициализация емкостью 10 элементов
 size = 0;
 }

 public void add(Object o) {
 if (size < elements.length) {
 elements[size] = o;
 } else {
//выделить массив большего размера и добавить
элемент,
 }
 ++size;
 }

 public Object get(int index) {
 if (index >= size)
 throw new
IndexOutOfBoundsException("Index: " + index + ", Size:
" + size);
 return elements[index];
 }
 public int size() { return size; }
}
В данном примере класс MyArrayList не является безопасным типом.
Например, если мы создаем MyArrayList, который предназначен для
хранения только String, но допустим в процессе работы с ним добавляется
Integer. Что произойдет? Компилятор не сможет обнаружить ошибку. Это
связано с тем, что MyArrayList предназначен для хранения объектов Object,
и любые классы Java являются производными от Object.

public class MyArrayListTest {
 public static void main(String[] args) {
MyArrayList strLst = new MyArrayList();
strLst.add("alpha");
 strLst.add("beta");
for (int i = 0; i < strLst.size(); ++i) {
 String str = (String)strLst.get(i);
 System.out.println(str);
 }
strLst.add(new Integer(1234));
for (int i = 0; i < strLst.size(); ++i) {
 String str = (String)strLst.get(i);
System.out.println(str);
 }
 }
}

Если вы намереваетесь создать список объектов String, но
непреднамеренно добавленный в этот список не-String-объекты будут
преобразованы к типу Object. Компилятор не сможет проверить, является
ли понижающее преобразование типов действительным во время
компиляции (это известно как позднее связывание или динамическое
связывание). Неправильное понижающее преобразование типов будет
выявлено только во время выполнения программы, в виде исключения
ClassCastException, а это слишком поздно, для того чтобы внести изменения
в код и исправить работу программы. Компилятор не сможет поймать эту
ошибку в момент компиляции. Вопрос в том, как заставить компилятор
поймать эту ошибку и обеспечить безопасность использования типа во
время выполнения.

Классы дженерики или параметризованные классы
В JDK введены так называемые обобщенные или параметризованные
типы – generics или по-другому обобщенные типы для решения
вышеописанной проблемы. Параметризованных (generic) классы и методы,
позволяют использовать более гибкую и в то же время достаточно строгую
типизацию, что особенно важно при работе с коллекциями. Использование
параметризации позволяет создавать классы, интерфейсы и методы, в
которых тип обрабатываемых данных задается как параметр.
Дженерики или обобщенные типы позволяют вам абстрагироваться
от использования конкретных типов. Вы можете создать класс с таким
общим типом и предоставить информацию об определенном типе во время
создания экземпляра объекта типа класс. А компилятор сможет выполнить
необходимую проверку типов во время компиляции. Таким образом, вы
сможете убедиться, что во время выполнения программы не возникнет
ошибка выбора типа еще на этапе компиляции, что как раз является
безопасностью для используемого типа.
Рассмотрим пример:
Листинг 20.6 Объявление интерфейса java.util.List <E>:
public interface List<E> extends Collection<E> {
 boolean add(E o);
 void add(int index, E element);
 boolean addAll(Collection<? extends E> c);
 boolean containsAll(Collection<?> c);
 ......
}
Такая запись - <E> называется формальным параметром типа,
который может использоваться для передачи параметров «типа» во время
создания фактического экземпляра типа. Механизм похож на вызов метода
Напомним, что в определении метода мы всегда объявляем формальные
параметры для передачи данных в метод (при описании метода
используются формальные параметры, а при вызове на их место
подставляются аргументы). Например как представлено ниже:
// Определение метода
public static int max(int a, int b) {
// где int a, int b это формальные параметры
 return (a > b) ? a : b;
}
А во время вызова метода формальные параметры заменяются
фактическими параметрами (аргументами). Например так:
//Вызов: формальные параметры, замененные
фактическими параметрами
int maximum = max(55, 66);
// 55 и 66 теперь фактические параметры
int a = 77, b = 88;
maximum = max(a, b); // a и b теперь
фактические параметры
Параметры формального типа, используемые в объявлении класса,
имеют ту же цель, что и формальные параметры, используемые в
объявлении метода. Класс может использовать формальные параметры
типа для получения информации о типе, когда экземпляр создается для
этого класса. Фактические типы, используемые во время создания,
называются фактическими типами параметров.
Вернемся к java. util.List <E>, итак в действительности, когда тип
определен, например List <Integer>, все вхождения параметра формального
типа <E> заменяются актуальным или фактическим параметром типа
<Integer>. Используя эту дополнительную информацию о типе, компилятор
может выполнить проверку типа во время компиляции и убедиться, что во
время выполнения не будет ошибки при использовании типов.

Конвенция кода Java об именах для формальных типов
Мы должны помнить, что написания “чистого кода” необходимо
руководствоваться конвенцией кода на Java. Поэтому, для создания имен
формальных типов используйте один и тот же символ в верхнем регистре.
Например,
• <E> для элемента коллекции;
• <T> для обобщенного типа;
• <K, V> ключ и значение.
• <N> для чисел
• S,U,V, и т.д. для второго, третьего, четвертого типа параметра
Рассмотрим пример параметризованного или обобщенного типа как
класса. В нашем примере класс GenericBox принимает общий параметр
типа E, содержит содержимое типа E. Конструктор, геттер и сеттер
работают с параметризованным типом E. Метод нашего класса toString()
демонстрирует фактический тип содержимого.
Листинг 20.7 Пример параметризованного класса
public class GenericBox<E> {
 // Private переменная класса
 private E content;
 // конструктор
 public GenericBox(E content) {
 this.content = content;
 }
 public E getContent() {
 return content;
 }
 public void setContent(E content) {
 this.content = content;
 }
 public String toString() {
 return content + " (" + content.getClass() +
")";
 }
}
В следующем примере мы создаем GenericBoxes с различными
типами (String, Integer и Double). Обратите внимание, что при
преобразовании типов происходит автоматическая автоупаковка и
распаковка для преобразования между примитивами и объектамиоболочками (мы с вами это изучали ранее).
Листинг 20.8 Пример использования параметризованного класса
public class TestGenericBox {
 public static void main(String[] args) {
 GenericBox<String> box1 = new
GenericBox<String>("Hello");
 String str = box1.getContent(); // явного
понижающего преобразования (downcasting) не требуется
 System.out.println(box1);
 GenericBox<Integer> box2 = new
GenericBox<Integer>(123);
//автоупаковка типа int в тип Integer
 int i = box2.getContent(); // (downcast)
понижающее преобр. к типу Integer, автоупаковка в тип
int
 System.out.println(box2);
 GenericBox<Double> box3 = new
GenericBox<Double>(55.66);
////автоупаковка типа double в тип Double
 double d = box3.getContent(); //
(downcast) понижающее преобр. к типу Double,
//автоупаковка в тип double
 System.out.println(box3);
 }
}
Вывод программы:
Hello (class java.lang.String)
123 (class java.lang.Integer)
55.66 (class java.lang.Double)

39.Стирание типов
Из предыдущего примера может создаться видимость того, что
компилятор заменяет параметризованный тип <E> актуальным или
фактическим типом (таким как String, Integer) во время создания экземпляра
объекта типа класс. Если это так, то компилятору необходимо будет
создавать новый класс для каждого актуального или фактического типа
(аналогично шаблону C ++).
На самом же деле происходит следующее - компилятор заменяет всю
ссылку на параметризованный тип E на ссылку на Object, выполняет
проверку типа и вставляет требуемые операторы, обеспечивающие
понижающее приведения типов. Например, GenericBox компилируется
следующим образом (который совместим с кодами без дженериков):
Листинг 21.1 Пример класса GenericBox с полем Object
public class GenericBox {
 // Private переменная
 private Object content;
 // Конструктор
 public GenericBox(Object content) {
 this.content = content;
 }
 public Object getContent() {
 return content;
 }
 public void setContent(Object content) {
 this.content = content;
 }
 public String toString() {
 return content + " (" + content.getClass() +
")";
 }
}
Компилятор сам вставляет требуемый оператор понижения типа
(downcasting) в код:
GenericBox box1 = new GenericBox("Hello"); //
upcast безопасно для типов
String str = (String)box1.getContent(); //
компилятор вставляет операцию понижения типа
(downcast)
System.out.println(box1);
Вывод. Таким образом, для всех типов используется одно и то же
определение класса. Самое главное, что байт-код всегда совместим с теми
классами, у которых нет дженериков. Этот процесс называется стиранием
типа.
Рассмотрим операцию “стирания типов” с помощью нашего
«безопасного типа» ArrayList, который мы рассматривали ранее в
паримере.
Вернемся, к примеру MyArrayList. С использованием дженериков
мы можем переписать нашу программу как показано в листинге ниже:
Листинг 21.2 Пример параметризованного класса GenericBox
//Динамически выделяемая память для массива с
дженериками
public class MyGenericArrayList<E> {
 private int size;
// количество элементов- емкость списка
 private Object[] elements;

 public MyGenericArrayList() { //конструктор
 elements = new Object[10];
// выделяем память сразу для 10 элементов списка при
его создании
 size = 0;
 }

 public void add(E e) {
 if (size < elements.length) {
 elements[size] = e;
 } else {
// добавляем элемент к списку и увеличиваем счетчик
количества элементов
 }
 ++size;
 }

 public E get(int index) {
 if (index >= size)
 throw new
IndexOutOfBoundsException("Index: " + index + ", Size:
" + size);
 return (E)elements[index];
 }

 public int size() { return size; }
}
В объявлении MyGenericArrayList <E> объявляется класс-дженерик с
формальным параметром типа <E>. Во время фактического создания
объектов типа класс, например, MyGenericArrayList <String>,
определенного типа <String> или параметра фактического типа,
подставляется вместо параметра формального типа <E>.
Помните! Что Дженерики реализуются компилятором Java в качестве
интерфейсного преобразования, называемого стиранием, которое
переводит или перезаписывает код, который использует дженерики в не
обобщенный код (для обеспечения обратной совместимости). Это
преобразование стирает всю информацию об общем типа. Например,
ArrayList <Integer> станет ArrayList. Параметр формального типа, такой как
<E>, заменяется объектом по умолчанию (или верхней границей типа).
Когда результирующий код не корректен, компилятор вставляет оператор
преобразования типа.
Следовательно, код, транслированный компилятором, т о есть
переведенный код выглядит следующим образом:
Листинг 21.3 Пример кода транслированногоо компилятором
public class MyGenericArrayList {
 private int size; // количество элементов
 private Object[] elements;

 public MyGenericArrayList() { // конструктор
 elements = new Object[10]; // выделяем
память для первых 10 объектов
 size = 0;
 }

 // Компилятор заменяет параметризованный тип E
на Object, но проверяет, что параметр e имеет тип E,
когда //он используется для обеспечения безопасности
типа
 public void add(Object e) {
 if (size < elements.length) {
 elements[size] = e;
 } else {
 // allocate a larger array and add the
element, omitted
 }
 ++size;
 }

 // Компилятор заменяет E на Object и вводит
оператор понижающего преобразования типов (E <E>) для
//типа возвращаемого значения при вызове метода
 public Object get(int index) {
 if (index >= size)
 throw new
IndexOutOfBoundsException("Index: " + index + ", Size:
" + size);
 return (Object)elements[index];
 }

 public int size() {
 return size;
 }
}
Когда класс создается с использованием актуального или
фактического параметра типа, например. MyGenericArrayList <String>,
компилятор гарантирует, что add(E e) работает только с типом String. Он
также вставляет соответствующий оператор понижающее преобразование
типов в соответствие с типом возвращаемого значения E для метода get().
Например,
Листинг 21.4 Пример использования класса дженерика
public class MyGenericArrayListTest {
 public static void main(String[] args) {
 // безопасный тип для хранения списка
объектов Strings (строк)
 MyGenericArrayList<String> strLst = new
MyGenericArrayList <String>();

 strLst.add("alpha"); // здесь компилятор
проверяет, является ли аргумент типом String
 strLst.add("beta");

 for (int i = 0; i < strLst.size(); ++i) {
 String str = strLst.get(i); //компилятор
вставляет оператор
//понижающего преобразования operator (String)
 System.out.println(str);
 }
 strLst.add(new Integer(1234)); //
компилятор обнаруживает аргумент,
//который не является объектом String, происходит
ошибка компиляции
}
}
Выводы: с помощью дженериков компилятор может выполнять
проверку типов во время компиляции и обеспечивать безопасность
использования типов во время выполнения.
Запомните. В отличие от «шаблона» в C ++, который создает новый
тип для каждого определенного параметризованного типа, в Java класс
generics компилируется только один раз, и есть только один файл класса,
который используется для создания экземпляров для всех конкретных
типов.

Обобщенные методы (параметризованные методы)
Методы также могут быть определены с помощью общих типов
(аналогично родовому классу). Например,
Листинг 21.5 Пример параметризованного метода
public static <E> void ArrayToArrayList(E[] a,
ArrayList<E> lst) {
 for (E e : a) lst.add(e);
}
При объявлении обобщенного метода или метода-дженерика могут
объявляться параметры формального типа (например, такие как <E>, <K,
V>) перед возвращаемым типом (в примере выше это static <E> void).
Параметры формального типа могут затем использоваться в качестве
заполнителей для типа возвращаемого значения, параметров метода и
локальных переменных в общем методе для правильной проверки типов
компилятором.
Подобно классам-дженерикам, когда компилятор переводит общий
метод, он заменяет параметры формального типа, используя операцию
стирания типа. Все типы заменяются типом Object по умолчанию (или
верхней границей типа – типом классом, стоящим на самой вершине
иерархии наследования). Переведенная на язык компилятора версия
программы выглядит следующим образом:
Листинг 21.6 Пример трансляции кода компилятором
public static void ArrayToArrayList(Object[] a,
ArrayList lst) {
// компилятор проверяет, есть ли тип E[],
// lst имеет тип ArrayList<E>
ArrayList<E> for (Object e : a) lst.add(e);
// компилятор проверяет является ли e типом E
}
Компилятор всегда проверяет, что a имеет тип E[], lst имеет тип
ArrayList <E>, а e имеет тип E во время вызова для обеспечения
безопасности типа.

Пример класса с использованием параметризованного
метода
import java.util.*;
public class TestGenericMethod {
 public static <E> void ArrayToArrayList(E[] a,
ArrayList<E> lst) {
 for (E e : a) lst.add(e);
 }
public static void main(String[] args) {
ArrayList<Integer> lst = new ArrayList<Integer>();
 Integer[] intArray = {55, 66}; //
автоупаковка
 ArrayToArrayList(intArray, lst);
 for (Integer i : lst) System.out.println(i);

 String[] strArray = {"one", "two", "three"};
 //ArrayToArrayList(strArray, lst);
//ошибка компиляции ниже
 }
TestGenericMethod.java:16:<E>ArrayToArrayList(E[],jav
a.util.ArrayList<E>) in TestGenericMethod cannot be
applied to
(java.lang.String[],java.util.ArrayList<java.lang.Int
eger>) ArrayToArrayList(strArray, lst);
}
У дженериков есть необязательный синтаксис для указания типа для
общего метода. Вы можете поместить фактический тип в угловые скобки
<> между оператором точки и именем метода.

Подстановочный синтаксис в Java (WILD CARD)
Одним из наиболее сложных аспектов generic-типов (обобщенных
типов) в языке Java являются wildcards (подстановочные символы, в данном
случае – «?»), и особенно – толкование и разбор запутанных сообщений об
ошибках, происходящих при wildcard capture (подстановке вычисляемого
компилятором типа вместо wildcard). В своем труде «Теория и практика
Java» (Java theory and practice) старейший Java-разработчик Брайен Гетц
расшифровывает некоторые из наиболее загадочно выглядящих сообщений
об ошибках, выдаваемых компилятором «javac», и предлагает решения и
варианты обхода, которые помогут упростить использование genericтипов.
Рассмотрим следующую строку кода:
ArrayList<Object> lst = new ArrayList<String>();
Компиляция вызовет ошибку - «несовместимые типы», поскольку
ArrayList <String> не является ArrayList <Object>. Эта ошибка противоречит
нашей интуиции в отношении полиморфизма, поскольку мы часто
присваиваем экземпляр подкласса ссылке на суперкласс.
Рассмотрим эти два утверждения:
List<String> strLst = new ArrayList<String>();
// строчка 1
List<Object> objLst = strList;
// строчка 2 – ошибка компиляции
Выполнение строки 2 генерирует ошибку компиляции. Но если
строка 2 выполняется, то некоторые объекты добавляются в objLst, а strLst
будут «повреждены» и больше не будет содержать только строки. (так-как
переменные objLst и strLst содержат одинаковую ссылку или ссылаются на
одну и ту-же область памяти).
Учитывая вышеизложенное, предположим, что мы хотим написать
метод printList (List <.>) Для печати элементов списка. Если мы определяем
метод как printList (List <Object> lst), он может принимать только аргумент
List <object>, но не List <String> или List <Integer>. Например,
Листинг 21.8 Пример параметризованного метода для печати элементов
списка
import java.util.*;
public class TestGenericWildcard {

 public static void printList(List<Object> lst)
{ // принимает только список объектов,не список
подклассов объектов
 for (Object o : lst) System.out.println(o);
 }

 public static void main(String[] args) {
 List<Object> objLst = new
ArrayList<Object>();
 objLst.add(new Integer(55));
 printList(objLst); // соответствие

 List<String> strLst = new
ArrayList<String>();
 strLst.add("one");
 printList(strLst); // ошибка компиляции
 }
}

Использование подстановочного знака без ограничений в
описании типа <?>
Чтобы разрешить проблему, описанную выше, необходимо
использовать подстановочный знак (?), он используется в дженериках для
обозначения любого неизвестного типа. Например, мы можем переписать
наш printList () следующим образом, чтобы можно было передавать список
любого неизвестного типа.
public static void printList(List<?> lst) {
 for (Object o : lst) System.out.println(o);
}
Использование подстановочного знака в начале записи типа <?
extends тип>
Подстановочный знак <? extends type> обозначает тип и его подтип.
Например,
public static void printList(List<? extends
Number> lst) {
 for (Object o : lst) System.out.println(o);
}
List<? extends Number> принимает список Number и любой
подтипNumber, например, List <Integer> и List <Double>. Понятно, что
обозначение типа <?> можно интерпретировать как <? extends Object>,
который применим ко всем классам Java.
Другой пример,
//List<Number> lst = new ArrayList<Integer>(); //
ошибка компиляции
List<? extends Number> lst = new
ArrayList<Integer>();
На самом деле стирание типов обеспечивает совместимость вашего
кода со старыми версиями java, которые могут вообще не содержать
дженериков.


40.Абстрактные типы данных. Стек
Стек — это линейная структура данных, которая следует принципу
LIFO (Last In First Out) . Стек имеет один конец, куда мы можем добавлять
элементя и извлекать их оттуда, в отличие от очереди котрая имеет два
конца ( спереди и сзади).Стек содержит только один указатель top(
верхушка стека), указывающий на самый верхний элемент стека. Всякий
раз, когда элемент добавляется в стек, он добавляется на вершину стека, и
этот элемент может быть удален только из стека только сверху. Другими
словами, стек можно определить как контейнер, в котором вставка и
удаление элементов могут выполняться с одного конца, известного как
вершина стека.
Примеры стеков – пирамида, стопка тарелок или книг, магазин в
пистолете
Стеку присущи следующие характеристики:
• Стек — это абстрактный тип данных с заранее определенной
емкостью, что означает, что эта структура данных имеет
ограниченный размер, то есть может хранить количество
элементов, опредееленное размерностью стека.
• Это структура данных, в которой строго определен порядок
вставки и удаления элементов, и этот порядок может быть LIFO
или FILO.
Стандартные операции со стеком
Ниже приведены некоторые общие операции, реализованные в стеке:
• push(): когда мы добавляем элемент в стек, эта операция
называется push. Если стек заполнен, возникает состояние
переполнения.
• pop(): Когда мы удаляем элемент из стека, эта операция называется
pop. Если стек пуст, это означает, что в стеке нет элементов, это
состояние известно как состояние потери значимости.
• isEmpty(): определяет, пуст стек в настоящий момент или нетили
нет.
• isFull(): определяет, заполнен стек или нет.
• peek(): возвращает элемент в заданной позиции.
• count(): возвращает общее количество элементов, доступных в
стеке.
• change(): изменяет элемент в заданной позиции.
• display(): печатает все элементы, доступные в стеке.

Реализация стека на массиве на языке Джава
class Stack {
 // store elements of stack
 private int arr[];
 // represent top of stack
 private int top;
 // total capacity of the stack
 private int capacity;
 // Creating a stack
 Stack(int size) {
 // initialize the array
 // initialize the stack variables
 arr = new int[size];
 capacity = size;
 top = -1;
 }
 // push elements to the top of stack
 public void push(int x) {
 if (isFull()) {
 System.out.println("Stack OverFlow");
 // terminates the program
 System.exit(1);
 }
 // insert element on top of stack
 System.out.println("Inserting " + x);
 arr[++top] = x;
 }
 // pop elements from top of stack
 public int pop() {
 // if stack is empty
 // no element to pop
 if (isEmpty()) {
 System.out.println("STACK EMPTY");
 // terminates the program
 System.exit(1);
 }
 // pop element from top of stack
 return arr[top--];
 }
 // return size of the stack
 public int getSize() {
 return top + 1;
 }
 // check if the stack is empty
 public Boolean isEmpty() {
 return top == -1;
 }
 // check if the stack is full
 public Boolean isFull() {
 return top == capacity - 1;
 }
 // display elements of stack
 public void printStack() {
 for (int i = 0; i <= top; i++) {
 System.out.print(arr[i] + ", ");
 }
 }
 public static void main(String[] args) {
 Stack stack = new Stack(5);
 stack.push(1);
 stack.push(2);
 stack.push(3);
 System.out.print("Stack: ");
 stack.printStack();
 // remove element from stack
 stack.pop();
 System.out.println("\nAfter popping out");
 stack.printStack();
Пример реализации стека приведен в приложении A

41.Абстрактные типы данных. Очередь
1. Очередь можно пределить как упорядоченный список, который
позволяет выполнять операции вставки на одном конце, называемом REAR
, и операции удаления, которые выполняются на другом конце, называемом
FRONT
2. Очередь называется работает по дисциплине обслуживания
«первый пришел — первый обслужен» ( FCFS, first come first served)
3. Например, люди, стоящие в кассу магазина образуют оччередь
оплаты покупок.
Пример очереди можно увидеть на рис. 23.1. Операция dequeue
означает удаление элемента из начала очереди, а операция enqueue
добавление элемента в конец очереди.

Использование очередей в разработке программ.
Очереди широко используются
• в качестве списков ожидания для одного общего ресурса,
такого как принтер, диск, ЦП;
• при асинхронной передаче данных (когда данные не
передаются с одинаковой скоростью между двумя
процессами), например. трубы, файловый ввод-вывод, сокеты;
• в качестве буферов в большинстве приложений, таких как
медиаплеер MP3, проигрыватель компакт-дисков и т. д.;
• для ведения списка воспроизведения в медиаплеерах, чтобы
добавлять и удалять песни из списка воспроизведения;
• в операционных системах для обработки прерыванийи и при
реализации работы алгоритмов планирования и
диспетчиризации.

Виды очередей:
• Простая очередь или линейная очередь
• Циклическая очередь
• Очередь с приоритетами
• Двусторонняя очередь или Дек (англ. Deque)

Операции, выполняемые над очередью
Основные операции, которые можно выполнять в очереди,
перечислены ниже:
• Enqueue(): эта операция используется для вставки элемента в
конец очереди. Возвращает пустоту.
• Dequeue(): Операция выполняет удаление из внешнего
интерфейса очереди. Он также возвращает элемент, который
был удален из внешнего интерфейса. Он возвращает
целочисленное значение.
• Peek() Просмотр очереди: это третья операция, которая
возвращает элемент, на который указывает передний указатель
в очереди, но не удаляет его.
• isfFull() (Queue overflow): Проверка переполнения очереди
(заполнено): показывает состояние переполнения, когда
очередь полностью заполнена.
• isEmpty() (Queue underflow ): проверка очереди на пустоту
Показывает состояние потери значимости, когда очередь пуста,
т. е. в очереди нет элементов.
Способы реализации очереди
Существует два способа реализации очереди:
• Реализация с использованием массива: последовательное
размещение в очереди может быть реализовано с
использованием массива.
• Реализация с использованием связанного списка: размещение
связанного списка в очереди может быть реализовано с
использованием связанного списка.

Реализация очереди на языке Джава
public class Queue {
 int SIZE = 5;
 int items[] = new int[SIZE];
 int front, rear;
 Queue() {
 front = -1;
 rear = -1;
 }
 // check if the queue is full
 boolean isFull() {
 if (front == 0 && rear == SIZE - 1) {
 return true;
 }
 return false;
 }
 // check if the queue is empty
 boolean isEmpty() {
 if (front == -1)
 return true;
 else
 return false;
 }
 // insert elements to the queue
 void enQueue(int element) {
 // if queue is full
 if (isFull()) {
 System.out.println("Queue is full");
 }
 else {
 if (front == -1) {
 // mark front denote first element of
queue
 front = 0;
 }
 rear++;
 // insert element at the rear
 items[rear] = element;
 System.out.println("Insert " + element);
 }
 }
 // delete element from the queue
 int deQueue() {
 int element;
 // if queue is empty
 if (isEmpty()) {
 System.out.println("Queue is empty");
 return (-1);
 }
 else {
 // remove element from the front of queue
 element = items[front];
 // if the queue has only one element
 if (front >= rear) {
 front = -1;
 rear = -1;
 }
 else {
 // mark next element as the front
 front++;
 }
 System.out.println( element + "
Deleted");
 return (element);
 }
 }
 // display element of the queue
 void display() {
 int i;
 if (isEmpty()) {
 System.out.println("Empty Queue");
 }
 else {
 // display the front of the queue
 System.out.println("\nFront index-> " +
front);
 // display element of the queue
 System.out.println("Items -> ");
 for (i = front; i <= rear; i++)
 System.out.print(items[i] + " ");
 // display the rear of the queue
 System.out.println("\nRear index-> " +
rear);
 }
 }
 public static void main(String[] args) {
 // create an object of Queue class
 Queue q = new Queue();
 // try to delete element from the queue
 // currently queue is empty
 // so deletion is not possible
 q.deQueue();
 // insert elements to the queue
 for(int i = 1; i < 6; i ++) {
 q.enQueue(i);
 }
 // 6th element can't be added to queue
because queue is full
 q.enQueue(6);
 q.display();
 // deQueue removes element entered first i.e.
1
 q.deQueue();
 // Now we have just 4 elements
 q.display();
 }
}

Ведь язык Java
предоставляет встроенный интерфейс Queue, который можно использовать
для реализации очереди. Такая реализация представлена на листинге ниже.
Листинг 23.2 Реализация очереди с помощью интерфейса Queue
import java.util.Queue;
import java.util.LinkedList;
class Main {
 public static void main(String[] args) {
 // Creating Queue using the LinkedList class
 Queue<Integer> numbers = new LinkedList<>();
 // enqueue
 // insert element at the rear of the queue
 numbers.offer(1);
 numbers.offer(2);
 numbers.offer(3);
 System.out.println("Queue: " + numbers);
 // dequeue
 // delete element from the front of the queue
 int removedNumber = numbers.poll();
 System.out.println("Removed Element: " +
removedNumber);
 System.out.println("Queue after deletion: " +
numbers);
 }
}

42.Паттерны проектирования.
Паттерны (или шаблоны) проектирования описывают типичные
способы решения часто встречающихся проблем при проектировании
программ.
Некоторые из преимуществ использования шаблонов
проектирования:
1) Шаблоны проектирования уже заранее определены и
обеспечивают стандартный отраслевой подход к решению
повторяющихся в программном коде проблем, вследствие этого
разумное применение шаблона проектирования экономит
время на разработку.
2) Использование шаблонов проектирования способствует
реализации одного из преимуществ ООП – повторного
использования кода, что приводит к более надежному и
удобному в сопровождении коду. Это помогает снизить общую
стоимость владения программного продукта.
3) Поскольку шаблоны проектирования заранее определены то это
упрощает понимание и отладку нашего кода. Это приводит к
более быстрому развитию проектов, так как новые новые
члены команды понимают код.
Шаблоны проектирования Джава делятся на три категории:
порождающие, структурные и поведенческие шаблоны проектирования.
Так же есть еще шаблоны проектировани, например MVC – model-viewcontroller.

Шаблон проектирования Фабрика (factory), его также называют
фабричный метод используется, когда у нас есть суперкласс с несколькими
подклассами, и на основе ввода нам нужно вернуть один из подклассов.
Этот шаблон снимает с себя ответственность за создание экземпляра класса
из клиентской программы в класс фабрики. Давайте сначала узнаем, как
реализовать фабричный шаблон проектирования в java, а затем мы
рассмотрим преимущества фабричного шаблона. Мы увидим некоторые
примеры использования фабричного шаблона проектирования в JDK.
Обратите внимание, что этот шаблон также известен как шаблон
проектирования фабричный метод.
Суперкласс в шаблоне проектирования Фабрика может быть
интерфейсом, абстрактным классом или обычным классом Java. Для нашего
примера шаблона проектирования фабрики у нас есть абстрактный
суперкласс с переопределенным toString() методом для целей тестирования

Пример абстрактного класса Computer.java
package ru.mirea.it;
public abstract class Computer {
 public abstract String getRAM();
 public abstract String getHDD();
 public abstract String getCPU();
 @Override
 public String toString(){
 return "RAM= "+this.getRAM()+",
HDD="+this.getHDD()+", CPU="+this.getCPU();
 }
}
Создадим производные классы шаблона фабрики. Допустим, у нас
есть два подкласса ПК и сервер с реализацией ниже см листинг 24.2.
Листинг 24.2 –Дочерний класс PC фабричного шаблона.
package ru.mirea.it;
public class PC extends Computer {
 private String ram;
 private String hdd;
 private String cpu;
 public PC(String ram, String hdd, String cpu){
 this.ram=ram;
 this.hdd=hdd;
 this.cpu=cpu;
 }
 @Override
 public String getRAM() {
 return this.ram;
 }
 @Override
 public String getHDD() {
 return this.hdd;
 }
 @Override
 public String getCPU() {
 return this.cpu;
 }
}
На листинге 24.3 представлен еще один дочерний класс шаблона
фабрика.
Листинг 24.3 –Дочерний класс Server фабричного шаблона.
package ru.mirea.it
public class Server extends Computer {
 private String ram;
 private String hdd;
 private String cpu;
 public Server(String ram, String hdd, String
cpu){
 this.ram=ram;
 this.hdd=hdd;
 this.cpu=cpu;
 }
 @Override
 public String getRAM() {
 return this.ram;
 }
 @Override
 public String getHDD() {
 return this.hdd;
 }
 @Override
 public String getCPU() {
 return this.cpu;
 }
}
Теперь, когда у нас есть готовые суперклассы и подклассы, мы можем
написать наш фабричный класс. На листинге 24.4 представлена его базовая
реализация.
Листинг 24.4 Базовая реализация фабричного класса
package ru.mirea.it;
import ru.mirea.it.Computer;
import ru.mirea.it.PC;
import ru.mirea.it.Server;
public class ComputerFactory {
 public static Computer getComputer(String type,
String ram, String hdd, String cpu){
 if("PC".equalsIgnoreCase(type)) return new
PC(ram, hdd, cpu);
 else if("Server".equalsIgnoreCase(type))
return new Server(ram, hdd, cpu);
 return null;
 }
}
Отметим некоторые важные моменты метода Factory Design Pattern;
Мы можем оставить класс Factory Singleton или оставить метод,
возвращающий подкласс, как статический .
Обратите внимание, что на основе входного параметра создается и
возвращается другой подкласс. getComputer() является заводским методом.
Простая тестовая клиентская программа, в которой используется
приведенная выше реализация шаблона проектирования factory
представлена на листинге 24.5.
Листинг 24.5 Класс Тестер
package ru.mirea.it.abstractfactory;
import ru.mirea.it.ComputerFactory;
import ru.mirea.it.Computer;
public class TestFactory {
 public static void main(String[] args) {
 Computer pc =
ComputerFactory.getComputer("pc","2 GB","500 GB","2.4
GHz");
 Computer server =
ComputerFactory.getComputer("server","16 GB","1
TB","2.9 GHz");
 System.out.println("Factory PC Config::"+pc);
 System.out.println("Factory Server
Config::"+server);
 }
}
Результат работы тестовой программы:
Factory PC Config::RAM= 2 GB, HDD=500 GB, CPU=2.4
GHz
Factory Server Config::RAM= 16 GB, HDD=1 TB,
CPU=2.9 GHz

Преимущества шаблона Фабрика
Шаблон проектирования Factory обеспечивает подход к коду для
интерфейса, а не для реализации.
Фабричный шаблон удаляет экземпляры реальных классов
реализации из клиентского кода. Фабричный шаблон делает наш код более
надежным, менее связанным и легко расширяемым. Например, мы можем
легко изменить реализацию класса ПК (PC), потому что клиентская
программа не знает об этом.
Основное преимущество, котрое мы получаем - Фабричный шаблон
обеспечивает абстракцию между реализацией и клиентскими классами
посредством наследования.

Примеры шаблонов проектирования Factory в JDK
Методы java.util.Calendar, ResourceBundle и NumberFormat
getInstance() используют шаблон Factory. Методы valueOf()метод в классахоболочках, таких как Boolean, Integer и т. д. также используют шаблон
Factory
Паттерн Abstract Factory похож на паттерн Factory и представляет
собой фабрику фабрик. Если вы знакомы с шаблоном проектирования
factory в java, вы заметите, что у нас есть один класс Factory, который
возвращает различные подклассы на основе предоставленных входных
данных, и для достижения этого класс factory использует операторы if-else
или switch. В шаблоне абстрактной фабрики мы избавляемся от блока if-else
и создаем класс фабрики для каждого подкласса, а затем класс абстрактной
фабрики, который возвращает подкласс на основе входного фабричного
класса.
Мы рассмотрели на листингах 24.1, 24.2, 24.3 классы, теперь прежде
всего нам нужно создать интерфейс Abstract Factory или абстрактный класс
.ComputerAbstractFactory.java см. листинг 24.6

Абстрактный класс .ComputerAbstractFactory.java
package ru.mirea.it.abstractfactory;
import ru.mirea.it.Computer;
public interface ComputerAbstractFactory {
 public Computer createComputer();
}
братите внимание, что метод createComputer() возвращает экземпляр
суперкласса Computer. Теперь наши фабричные классы будут
реализовывать этот интерфейс и возвращать соответствующий подкласс
PCFactory.java см.листинг 24.7
Листинг 24.7 Фабричный класс PCFactory.java
package ru.mirea.it.abstractfactory;
import ru.mirea.it.Computer;
import ru.mirea.it.PC;
public class PCFactory implements
ComputerAbstractFactory {
 private String ram;
 private String hdd;
 private String cpu;
 public PCFactory(String ram, String hdd, String
cpu){
 this.ram=ram;
 this.hdd=hdd;
 this.cpu=cpu;
 }
 @Override
 public Computer createComputer() {
 return new PC(ram,hdd,cpu);
 }
}
точно так же у нас будет фабричный класс для Server подкласса
ServerFactory.java см листинг 24.8
Листинг 24.8 Фабричный класс ServerFactory.java
package ru.mirea.it.abstractfactory;
import ru.mirea.it.Computer;
import ru.mirea.it.Server;
public class ServerFactory implements
ComputerAbstractFactory {
 private String ram;
 private String hdd;
 private String cpu;
 public ServerFactory(String ram, String hdd,
String cpu){
 this.ram=ram;
 this.hdd=hdd;
 this.cpu=cpu;
 }
 @Override
 public Computer createComputer() {
 return new Server(ram,hdd,cpu);
 }
}
Теперь мы создадим клиентский класс, который предоставит
клиентским классам точку входа для создания подклассов
ComputerFactory.java см листинг 24.9
Листинг 24.9 Класс ComputerFactory
package ru.mirea.it.abstractfactory;
import ru.mirea.it.Computer;
public class ComputerFactory {
 public static Computer
getComputer(ComputerAbstractFactory factory){
 return factory.createComputer();
 }
}
Обратите внимание, что это простой класс и метод getComputer,
принимающий аргумент ComputerAbstractFactory и возвращающий объект
Computer. На этом этапе реализацияуже должна быть понятной. Давайте
напишем простой тестовый метод и посмотрим, как использовать
абстрактную фабрику для получения экземпляров подклассов
TestDesignPatterns.java см листинг 24.10.
Листинг 24.10 Тестовый класс TestDesignPatterns.java
Package ru.mirea.it.design.test;
import ru.mirea.it.abstractfactory.PCFactory;
import
ru.mirea.it.design.abstractfactory.ServerFactory;
import ru.mirea.it..design.factory.ComputerFactory;
import ru.mirea.it.design.model.Computer;
public class TestDesignPatterns {
 public static void main(String[] args) {
 testAbstractFactory();
 }
 private static void testAbstractFactory() {
 Computer pc =
com.journaldev.design.abstractfactory.ComputerFactory
.getComputer(new PCFactory("2 GB","500 GB","2.4
GHz"));
 Computer server =
com.journaldev.design.abstractfactory.ComputerFactory
.getComputer(new ServerFactory("16 GB","1 TB","2.9
GHz"));
 System.out.println("AbstractFactory PC
Config::"+pc);
 System.out.println("AbstractFactory Server
Config::"+server);
 }
}
Результат работы тестовой программы
AbstractFactory PC Config::RAM= 2 GB, HDD=500 GB,
CPU=2.4 GHz
AbstractFactory Server Config::RAM= 16 GB, HDD=1
TB, CPU=2.9 GHz

43.классами Pattern, Matcher и PatternSyntaxException
Класс Pattern
Класс java.util.regex.Pattern применяется для определения регулярных
выражений, для которого ищется соответствие в строке, файле или другом
объекте представляющем собой некоторую последовательность символов.
Этот класс используется для простой обработки строк. Для более сложной
обработки строк используется класс Matcher, рассматриваемый ниже.
В классе Pattern объявлены следующие методы:
• compile(String regex) – возвращает Pattern, который соответствует regex;
• matcher(CharSequence input) – возвращает Matcher, с помощью которого
можно находить соответствия в строке input;
• matches(String regex, CharSequence input) – проверяет на соответствие
строки input шаблону regex;
• pattern() – возвращает строку, соответствующую шаблону;
• split(CharSequence input) – разбивает строку input, учитывая, что
разделителем является шаблон;
• split(CharSequence input, int limit) – разбивает строку input на не более
чем limit частей.
С помощью метода matches() класса Pattern можно проверять на
соответствие шаблону целой строки, но если необходимо найти соответствия
внутри строки, например, определять участки, которые соответствуют
шаблону, то класс Pattern не может быть использован. Для таких операций
необходимо использовать класс Matcher.
Класс Matcher
С помощью класса java.util.regex.Matcher можно получить больше
информации каждом соответствии.
Начальное состояние объекта типа Matcher не определено. Попытка
вызвать какой-либо метод класса для извлечения информации о найденном
соответствии приведет к возникновению ошибки IllegalStateException. Для
того чтобы начать работу с объектом Matcher нужно вызвать один из его
методов:
• matches() – проверяет, соответствует ли вся строка шаблону;
• lookingAt() – пытается найти последовательность символов,
начинающуюся с начала строки и соответствующую шаблону;
• find() или find(int start) – пытается найти последовательность символов,
соответствующих шаблону, в любом месте строки. Параметр start
указывает на начальную позицию поиска.
Иногда необходимо сбросить состояние объекта класса Matcher в
исходное, для этого применяется метод reset() или reset(CharSequence input),
который также устанавливает новую последовательность символов для
поиска.
Для замены всех подпоследовательностей символов, удовлетворяющих
шаблону, на заданную строку можно применить метод replaceAll(String
replacement).
Для того чтобы ограничить поиск границами входной
последовательности применяется метод region(int start, int end), а для
получения значения этих границ – regionEnd() и regionStart(). С регионами
связано несколько методов:
useAnchoringBounds(boolean b) – если установлен в true, то начало и
конец региона соответствуют символам ^ и $ соответственно;
hasAnchoringBounds() – проверяет закрепленность границ.
В регулярном выражении для более удобной обработки входной
последовательности применяются группы, которые помогают выделить части
найденной подпоследовательности. В шаблоне они обозначаются скобками
«(» и «)». Номера групп начинаются с единицы. Нулевая группа совпадает со
всей найденной подпоследовательностью. Далее приведены методы для
извлечения информации о группах:
end() – возвращает индекс последнего символа подпоследовательности,
удовлетворяющей шаблону;
end(int group) – возвращает индекс последнего символа указанной
группы;
group() – возвращает всю подпоследовательность, удовлетворяющую
шаблону;
group(int group) – возвращает конкретную группу;
groupCount() – возвращает количество групп;
start() – возвращает индекс первого символа подпоследовательности,
удовлетворяющей шаблону;
start(int group) – возвращает индекс первого символа указанной группы;
hitEnd() – возвращает истину, если был достигнут конец входной
последовательности.
Класс PatternSyntaxException
PatternSyntaxException представляет непроверяемое исключение,
которое отображает синтаксическую ошибку в шаблоне регулярного
выражения. Класс PatternSyntaxException представлен следующими методами,
которые помогут определить вам ошибку

Класс PatternSyntaxException
Объект PatternSyntaxException является непроверяемым исключением, которое
указывает на синтаксическую ошибку в образце регулярного выражения.
Правила написания:
- . — точка — это соответствие любому символу;
- ^строка — находит регулярное выражение, которое должно совпадать в
начале строки;
- строка$ — выражение, которое должно совпадать в конце строки;
- [абв] — только буквы а или б или в;
115
- [абв][яю] — только буквы а или б или в, за которыми следуют я или ю;
- [^abc] — когда символ каретки появляется в качестве первого символа в
квадратных скобках, он отрицает шаблон. Этот шаблон соответствует любому
символу, кроме a или b или c.
Метасимволы:
- \d — любая цифра — равнозначно [0-9];
- \D — только не цифра — равнозначно [^0-9];
- \s — символ пробела;
- \w — символ слова — равнозначно [a-zA-Z_0-9].
Квантификаторы
- * — символ звездочки означает от ноля до бесконечности;
- + — символ может встречаться от одного или несколько раз, сокращенно
{1,};
- ? — встречается ни разу или один раз, знак вопроса это сокращение для
{0,1};
- {X} — символ встречается X раз;
- {X,Y} — символ встречается от X до Y раз.


44.Java Collection Framework
Коллекции в Java являются контейнерами объектов, которые благодаря
полиморфизму может содержать объекты любого класса, производного от Object
(который на самом деле и есть любой класс).
Какие бывают Коллекции?
Существуют два главных интерфейса (рисунок 7.1) для всех типов коллекций в
Java:
- Collection<E>;
- Map<K,V>.

Другие Коллекции.
- Guava (Google Collections Library) - библиотека добавляет несколько
полезных реализаций структур данных, таких как мультимножество,
мультиотображение и двунаправленное отображение. Улучшена эффективность.
- Trove library - реализация коллекций, позволяющая хранить
примитивы (в Java Collections Framework примитивы хранить нельзя, только
оберточные типы), что позволяет повысить эффективность работы.
- PCJ (Primitive Collections for Java) - так же, как и Trove предназначены
для примитивных типов, что позволит повысить эффективность.
- Наконец, вы сами можете написать собственную коллекцию (тот же
связной список). Но данный подход не рекомендуется.
Рекомендуется для начала необходимо освоить базовые коллекции Java
которыми пользуются чаще всего. А также некоторые сторонние библиотеки
реализуют интерфейсы Java Collections Framework  То есть знание
иерархии классов базовых коллекций позволит более быстро освоить сторонние
библиотеки.

В библиотеке коллекций Java существует два базовых интерфейса, реализации
которых и представляют совокупность всех классов коллекций:
- Collection - коллекция содержит набор объектов (элементов);
- Map -описывает коллекцию, состоящую из пар "ключ — значение".
Хоть фреймворк называется Java Collections Framework, но интерфейс map и его
реализации входят в фреймворк тоже. Интерфейсы Collection и Map являются
базовыми, но они не есть единственными. Их расширяют другие интерфейсы,
добавляющие дополнительный функционал.
Collection - коллекция содержит набор объектов (элементов). Здесь определены
основные методы для манипуляции с данными, такие как вставка (add, addAll),
удаление (remove, removeAll, clear), поиск (contains).
Map - описывает коллекцию, состоящую из пар "ключ — значение". У каждого
ключа только одно значение, что соответствует математическому понятию
однозначной функции или отображения (тар). Такую коллекцию часто называют еще
словарем (dictionary) или ассоциативным массивом (associative array). Никак НЕ
относится к интерфейсу Collection и является самостоятельным.
Интерфейс Collection расширяют три базовых интерфейса:
- List;
- Set;
- Queue.
Рассмотрим, зачем нужен каждый:
List - Представляет собой неупорядоченную коллекцию, в которой допустимы
дублирующие значения. Иногда их называют последовательностями (sequence ).
Элементы такой коллекции пронумерованы, начиная от нуля, к ним можно
обратиться по индексу.
Set - описывает неупорядоченную коллекцию, не содержащую повторяющихся
элементов. Это соответствует математическому понятию множества (set).
Queue - очередь. Это коллекция, предназначенная для хранения элементов в
порядке, нужном для их обработки. В дополнение к базовым операциям интерфейса
Collection, очередь предоставляет дополнительные операции вставки, получения и
контроля.

Рассмотрим, зачем нужен каждый:
List - Представляет собой неупорядоченную коллекцию, в которой допустимы
дублирующие значения. Иногда их называют последовательностями (sequence ).
Элементы такой коллекции пронумерованы, начиная от нуля, к ним можно
обратиться по индексу.
Set - описывает неупорядоченную коллекцию, не содержащую повторяющихся
элементов. Это соответствует математическому понятию множества (set).
Queue - очередь. Это коллекция, предназначенная для хранения элементов в
порядке, нужном для их обработки. В дополнение к базовым операциям интерфейса
Collection, очередь предоставляет дополнительные операции вставки, получения и
контроля.

Класс java.util.LinkedList.
Используется, если вы хотите пройти по списку и посмотреть / изменить
элементы в списке, вы используете объект итератора для этого списка (так же, как с
другими коллекциями, которые реализуют Iterable интерфейс; все они имеют метод
iterator (), который возвращает итератор).

Итераторы в Java
Итератор имеет доступ к элементам некоторой коллекции и может работать с
ней в определенном порядке. Методы интерфейса Iterator<E> (над коллекцией или
набором элементов типа Е):
- boolean hasNext() // говорит, что существуют ли какие либо элементы слева, которые мы можем увидеть;
- E next() // возвращает следующий элемент;
- void remove() //удаляет текущий элемент из коллекции.

Интерфейс List и класс ArrayList.
Массив является индексируемой структурой: можно выбрать все элементы в
произвольном порядке, используя значение индекса. К элементам можно получить
последовательный доступ с помощью цикла, который увеличивает индекс.
Вы не можете:
- увеличивать или уменьшать длину;
- добавить элемент в указанную позицию без перемещения других
элементов, чтобы освободить место;
- удалить элемент в заданном положении без смещения других элементов,
чтобы заполнить возникший пробел.
В интерфейс List включены следующие операции:
- поиск заданного элемента;
- добавление элемента в любой конец;
- удаление элемента с любого конца;
- обход структуры списка без использования индекса.
Не все классы выполняют перечисленные операции с одинаковой степенью
эффективности. Массив предоставляет возможность хранить данные примитивных
типов, тогда как в списке из объектов типа класс хранятся ссылки на объекты (этому
способствует Autoboxing).

ArrayList - самая часто используемая коллекция. ArrayList
инкапсулирует в себе обычный массив, длина которого автоматически увеличивается
при добавлении новых элементов. Так как ArrayList использует массив, то время
доступа к элементу по индексу минимально (в отличии от LinkedList).
При удалении произвольного элемента из списка, все элементы, находящиеся
«правее» смещаются на одну ячейку влево, при этом реальный размер массива (его
емкость, capacity) не изменяется. Если при добавлении элемента, оказывается, что
массив полностью заполнен, будет создан новый массив размером (n * 3) / 2 + 1, в
него будут помещены все элементы из старого массива + новый, добавляемый
элемент.

LinkedList - Двусвязный список.
Это структура данных, состоящая из узлов, каждый из которых содержит как
собственно данные, так и две ссылки («связки») на следующий и предыдущий узел
списка.
Доступ к произвольному элементу осуществляется за линейное время (но
доступ к первому и последнему элементу списка всегда осуществляется за
константное время — ссылки постоянно хранятся на первый и последний, так что
добавление элемента в конец списка вовсе не значит, что придется перебирать весь
список в поисках последнего элемента). В целом же, LinkedList в абсолютных
величинах проигрывает ArrayList и по потребляемой памяти, и по скорости
выполнения операций.
Класс ArrayList.
Довольно-таки простой класс, который реализует интерфейс List. Имеет
улучшение по сравнению с массивами. Используется, если программист хочет
добавить новые элементы в конец списка, но по-прежнему нуждается в возможности
доступа к элементам, сохраненным в списке в произвольном порядке.
ArrayList является несихронизируемым динамически расширяемым
массивом с эффективным доступом по индексу.
Пример:
ArrayList<Integer> arr =
new ArrayList<Integer>(10);
arr.add(7);
ArrayList на самом деле не является списком (хотя реализует интерфейс
List) Если вам нужен список, то используйте класс LinkedList.
Класс Vector.
Vector это и синхронизируемый динамически расширяемый массив массив с
эффективным доступом по индексу.
Пример:
Vector<Integer> vec =
new Vector<Integer>(10);
vec.add(7);
Vector является старым контейнером (Java 1.0) и сейчас гораздо реже
используется, заменяется в основном ArrayList (Java 1.2), который не
синхронизируется.

Использование ArrayList.
ArrayList дает дополнительные возможности сверх того, что обеспечивают
обычные массивы. Сочетание Автоупаковки (Autoboxing) с Generic Collection
(коллекциями дженериков) дает вам возможность хранить и извлекать примитивные
типы данных при работе с ArrayList.
Односвязные списки и двусвязные списки. Реализация на Java.
ArrayList: методы добавления и удаления работают за линейное время,
потому что они требуют, чтобы цикл сдвига элементов в массиве подстилающей.
LinkedList преодолевает это ограничение, предоставляя возможность
добавлять или удалять элементы в любом месте в списке за постоянное время.
Каждый элемент списка (узел) содержит информационные поля и ссылку на
следующий узел, и необязательно, ссылку на предыдущий узел.
Узел списка.
Узел содержит поля данных и одну или несколько ссылок. Ссылка является
ссылкой на следующий узел. Узел обычно определяется внутри другого класса, что
делает его внутренним классом (inner) для контейнера.

DoubleLinkedList (двусвязный список).
Ограничения одно-связанный список включают в себя:
- вставка в начало списка O (1);
- вставка на другие позиции O(n) где n размер списка.
Можно вставить узел только после ссылочного узла. Можно удалить узел,
только если у нас есть ссылка на его узел-предшественник. Может проходить по
списку только в прямом направлении. Эти ограничения удаляются путем добавления
ссылки в каждом узле к предыдущему узлу (двусвязный список, рисунок 7.8).

Циклические списки.
Циклический связанный список (рисунок 7.7): связать последний узел
двусвязного списка с первым узлом и первый с последним.
Преимущество: может двигаться в прямом или обратном направлении по
списку, даже после того, как вы прошли последний или первый узел. Можно посетить
все элементы списка из любой начальной точки. Никогда нельзя выйти за пределы
списка (за последний элемент). Неудобство: бесконечный цикл.













 */




